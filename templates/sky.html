<!-- templates/sky.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Celestial Navigation - Constellations Only</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --panel: rgba(10,12,18,.82);
      --panel2: rgba(10,12,18,.92);
      --text: rgba(255,255,255,.90);
      --muted: rgba(255,255,255,.58);
      --glow: rgba(255,255,255,.55);
      --line: rgba(197,160,89,.65);
      --lineSoft: rgba(197,160,89,.18);
      --gold: rgba(197,160,89,.92);
    }

    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
    #sky-container{
      position:fixed; inset:0;
      background-image:url('/static/images/dark_sky.jpg');
      background-size:cover; background-position:center;
      cursor:grab;
    }
    #sky-container.dragging{ cursor:grabbing; }
    svg{ width:100%; height:100%; display:block; }

    /* Stars */
    .star.line{
      fill: rgba(255,255,255,.88);
      filter: drop-shadow(0 0 8px rgba(255,255,255,.18));
      opacity:.72;
      pointer-events:none;
    }
    .star.major{
      fill:#fff;
      filter: drop-shadow(0 0 10px var(--glow));
      cursor:pointer;
      opacity:.95;
      transition: opacity .18s ease;
      pointer-events:auto;
    }

    /* Focus dimming */
    #view-port.has-focus .const-group:not(.is-focus) .const-line{ opacity:.08; }
    #view-port.has-focus .const-group:not(.is-focus) .const-label{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.major{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.line{ opacity:.10; }

    .const-line{
      stroke: var(--lineSoft);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
      opacity: .70;
      pointer-events:none;
      transition: stroke .22s ease, opacity .22s ease, filter .22s ease;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.18));
    }
    .const-group.is-focus .const-line{
      stroke: var(--line);
      opacity: 1;
      filter: drop-shadow(0 0 16px rgba(197,160,89,.35));
    }

    .const-label{
      fill: var(--muted);
      font-weight: 900;
      letter-spacing: .20em;
      text-transform: uppercase;
      pointer-events:none;
      user-select:none;
      paint-order: stroke fill;
      stroke: rgba(0,0,0,.55);
      stroke-width: 3px;
      transition: opacity .18s ease;
    }
    .const-group.is-focus .const-label{ opacity: 1; fill: rgba(255,255,255,.78); }

    .const-hit{
      fill: rgba(255,255,255,.0001);
      stroke: rgba(255,255,255,0);
      pointer-events: all;
      cursor: pointer;
    }

    /* =========================
       TOP RIGHT CONTROLS (compact)
       ========================= */
    #ui-overlay{
      position:fixed;
      top:12px;
      right:12px;
      z-index:2100;
      background: var(--panel);
      backdrop-filter: blur(16px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 7px 8px;
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap: nowrap;
      justify-content:flex-end;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      max-width: calc(100vw - 24px);
    }
    #ui-overlay .ctl{
      background: rgba(255,255,255,.06) !important;
      border:1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      border-radius: 999px !important;
      padding: 6px 9px;
      font-size: .84rem;
      line-height: 1.05;
      height: 32px;
      box-shadow: none !important;
    }
    #ui-overlay .btn{
      border-radius: 999px;
      padding: 6px 9px;
      font-weight: 900;
      letter-spacing:.01em;
      white-space:nowrap;
      font-size: .84rem;
      line-height: 1.05;
      height: 32px;
    }
    #ui-overlay #lat, #ui-overlay #lon{ width: 112px; }
    #ui-overlay #season{ width: 148px; }

    @media (max-width: 560px){
      #ui-overlay{ flex-wrap: wrap; border-radius: 16px; padding: 10px; }
      #ui-overlay #lat, #ui-overlay #lon{ width: 44vw; min-width: 120px; }
      #ui-overlay #season{ width: 52vw; min-width: 150px; }
    }

    /* =========================
       Finder -> LEFT (compact) + toggle button
       ========================= */
    #finder-toggle{
      position:fixed;
      top:12px;
      left:12px;
      z-index:2050;
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:7px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(14px);
      color: rgba(255,255,255,.92);
      box-shadow: 0 10px 40px rgba(0,0,0,.40);
      cursor:pointer;
      user-select:none;
      font-weight: 950;
      letter-spacing:.01em;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      height: 32px;
      font-size: .84rem;
      line-height: 1;
    }
    #finder-toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }
    #finder-toggle .pill{
      width:9px; height:9px; border-radius:999px;
      background: var(--gold);
      box-shadow: 0 0 14px rgba(197,160,89,.45);
      flex: 0 0 auto;
    }

    #finder{
      position:fixed;
      top:48px; left:12px;
      width:270px;
      max-width: calc(100vw - 24px);
      background: var(--panel);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      z-index:2000;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      transition: transform .55s cubic-bezier(.16,1,.3,1), opacity .25s ease;
      transform-origin: top left;
    }
    #finder.is-hidden{
      opacity: 0;
      transform: translateX(-10px) scale(.95);
      pointer-events:none;
    }

    #finder .head{
      padding:10px 10px 8px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    #finder .title{
      color:var(--text);
      font-weight:950;
      letter-spacing:.01em;
      font-size:.95rem;
      margin:0 0 8px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    #finder .smallhint{
      color:var(--muted);
      font-size:.78rem;
      margin:6px 0 0 0;
      line-height:1.25;
    }
    #finder .body{
      padding: 8px 10px 10px;
      max-height: calc(100vh - 180px);
      overflow:auto;
    }
    #finder input{
      background: rgba(255,255,255,.06) !important;
      border: 1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      height: 32px;
      padding: 6px 10px;
      font-size:.84rem;
      border-radius: 12px;
    }
    #finder input::placeholder{ color: rgba(255,255,255,.55); }

    .const-item{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:8px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      margin:7px 0;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .const-item:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
    }
    .const-item.active{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
    }
    .const-name{ color:var(--text); font-weight:900; letter-spacing:.01em; font-size:.90rem; }
    .const-count{ color:var(--muted); font-size:.80rem; }

    /* =========================
       MINIMAP (right bottom) + toggle button
       ========================= */
    #minimap-toggle{
      position:fixed;
      right:12px;
      bottom:12px;
      z-index:2150;
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(14px);
      box-shadow: 0 10px 40px rgba(0,0,0,.40);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      color: rgba(255,255,255,.92);
      font-weight: 950;
      line-height: 1;
    }
    #minimap-toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }

    #minimap{
      position:fixed;
      right:12px;
      bottom:54px; /* above the toggle */
      width: 220px;
      height: 160px;
      max-width: calc(100vw - 24px);
      background: rgba(0,0,0,.34);
      backdrop-filter: blur(14px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      z-index:2140;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      overflow:hidden;
      transform-origin: bottom right;
      transition: transform .55s cubic-bezier(.16,1,.3,1), opacity .25s ease;
    }
    #minimap.is-hidden{
      opacity: 0;
      transform: translateY(10px) scale(.95);
      pointer-events:none;
    }
    #minimap svg{ width:100%; height:100%; display:block; }
    .mm-bg{ fill: rgba(0,0,0,.12); }

    /* Only ONE gold dot per constellation */
    .mm-const{
      fill: rgba(197,160,89,.86);
      opacity: .98;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.25));
    }
    .mm-const.focus{
      fill: rgba(255,255,255,.95);
      opacity: 1;
      filter: drop-shadow(0 0 14px rgba(255,255,255,.25));
    }

    .mm-rect{
      fill: rgba(127,211,255,.08);
      stroke: rgba(127,211,255,.55);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      rx: 6; ry: 6;
    }
    .mm-hint{
      position:absolute;
      left:10px;
      bottom:8px;
      font-size:.74rem;
      color: rgba(255,255,255,.72);
      letter-spacing:.01em;
      user-select:none;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
    }

    /* Sidebar */
    #sidebar{
      position:fixed; right:-520px; top:0; bottom:0;
      width:480px; max-width: calc(100vw - 36px);
      background: var(--panel2);
      backdrop-filter: blur(22px);
      border-left:1px solid rgba(255,255,255,.12);
      z-index:2200;
      transition: .55s cubic-bezier(.16,1,.3,1);
      padding:24px 22px;
      color:#fff;
      overflow:auto;
    }
    #sidebar.open{ right:0; }
    #closeSide{
      cursor:pointer; opacity:.65; font-size:1.8rem; line-height:1;
      width:44px; height:44px; border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    #s-name{ font-weight: 950; margin:14px 0 6px 0; }
    #s-const{ color:#7fd3ff; letter-spacing:.22em; text-transform:uppercase; font-size:.82rem; margin:0 0 14px 0; }
    #s-meta .rowish{
      display:flex; justify-content:space-between; gap:14px;
      padding:10px 0; border-bottom: 1px solid rgba(255,255,255,.08);
      font-size:.92rem;
    }
    #s-meta .rowish b{ font-weight:950; }
    #s-audio{ width:100%; filter: invert(1); margin-top:12px; }

    /* Toast */
    #toast-wrap{
      position:fixed; top:60px; right:12px;
      z-index:2300;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none;
    }
    .toastish{
      pointer-events:none;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(12px);
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      transform: translateY(-6px);
      opacity: 0;
      transition: opacity .22s ease, transform .22s ease;
      max-width: min(520px, calc(100vw - 24px));
      line-height: 1.35;
    }
    .toastish.show{ opacity: 1; transform: translateY(0); }
    .toastish .t1{ font-weight: 950; }
    .toastish .t2{ color: rgba(255,255,255,.70); font-size:.9rem; margin-top:2px; }
  </style>
</head>

<body>
  <div id="sky-container">
    <svg id="sky-svg">
      <g id="view-port">
        <g id="groups-layer"></g>
      </g>
    </svg>
  </div>

  <!-- TOP RIGHT CONTROLS -->
  <div id="ui-overlay">
    <button id="btn-loc" class="btn btn-outline-light">Use my location</button>
    <input id="lat" class="ctl form-control" placeholder="Lat" value="37.5665" />
    <input id="lon" class="ctl form-control" placeholder="Lon" value="126.9780" />
    <select id="season" class="ctl form-select">
      <option value="spring">Spring (Mar 21)</option>
      <option value="summer">Summer (Jun 21)</option>
      <option value="fall">Fall (Sep 22)</option>
      <option value="winter" selected>Winter (Dec 21)</option>
    </select>
    <input id="hour" type="number" min="0" max="23" class="ctl form-control d-none" value="21" title="Local hour" />
    <button id="btn-go" class="btn btn-light">Show sky</button>
  </div>

  <!-- LEFT FINDER TOGGLE -->
  <div id="finder-toggle" title="Toggle Finder" role="button" tabindex="0" aria-controls="finder" aria-expanded="true">
    <span class="pill"></span>
    <span>Finder</span>
  </div>

  <!-- LEFT FINDER -->
  <div id="finder">
    <div class="head">
      <div class="title">
        <span>Constellation Finder</span>
        <button id="btn-reset" class="btn btn-sm btn-outline-light" style="border-radius:999px; padding:4px 8px; height:28px; font-size:.78rem;">Reset</button>
      </div>
      <input id="const-q" class="form-control" placeholder="Search (e.g., Orion)" />
      <p class="smallhint">Hover to highlight · click to zoom · click audio stars.</p>
    </div>
    <div class="body" id="const-list"></div>
  </div>

  <!-- MINIMAP TOGGLE (right bottom) -->
  <div id="minimap-toggle" title="Toggle minimap" role="button" tabindex="0" aria-controls="minimap" aria-expanded="false">◎</div>

  <!-- MINIMAP PANEL -->
  <div id="minimap" class="is-hidden" aria-hidden="true">
    <svg id="mm-svg" viewBox="0 0 220 160" preserveAspectRatio="none">
      <rect class="mm-bg" x="0" y="0" width="220" height="160"></rect>
      <g id="mm-consts"></g>
      <rect id="mm-rect" class="mm-rect" x="70" y="50" width="70" height="60"></rect>
    </svg>
    <div class="mm-hint">Minimap · dots = constellations</div>
  </div>

  <div id="sidebar">
    <div class="d-flex justify-content-end">
      <div id="closeSide" title="Close">&times;</div>
    </div>
    <h1 id="s-name">Star</h1>
    <p id="s-const">CONSTELLATION</p>
    <audio id="s-audio" controls></audio>
    <div id="s-meta" class="mt-3"></div>
  </div>

  <div id="toast-wrap" aria-live="polite" aria-atomic="true"></div>

<script>
  // =========================
  // TUNE
  // =========================
  const SKY_SCALE = 34;
  const CONST_SPREAD = 2.6;
  const INTRA_SPREAD = 1.0;

  const ZOOM_MIN = 0.35, ZOOM_MAX = 9.0;
  const LABEL_SHOW_ZOOM = 0.85;

  const MIN_ALT = -8;

  const SNAP_AUDIO_TO_LINES = true;
  const SNAP_PX_AT_ZOOM1 = 26;
  const KEEP_MAX_PX_AT_ZOOM1 = 36;

  // Initial view: MAX zoom-out
  const INITIAL_ZOOM = ZOOM_MIN;

  // =========================
  // STATE
  // =========================
  let CONSTS = [];
  let CONST_INFO = {};
  let FOCUSED_CONST = null;

  const svg = document.getElementById("sky-svg");
  const viewport = document.getElementById("view-port");
  const groupsLayer = document.getElementById("groups-layer");
  const sky = document.getElementById("sky-container");

  // minimap
  const mm = {
    wrap: document.getElementById("minimap"),
    toggle: document.getElementById("minimap-toggle"),
    layer: document.getElementById("mm-consts"),
    rect: document.getElementById("mm-rect"),
    W: 220, H: 160
  };
  let MINIMAP_OPEN = false;
  let WORLD_BOUNDS = null;

  // =========================
  // Finder toggle
  // =========================
  const finder = document.getElementById("finder");
  const finderToggle = document.getElementById("finder-toggle");

  function setFinderOpen(open){
    finder.classList.toggle("is-hidden", !open);
    finderToggle.setAttribute("aria-expanded", open ? "true" : "false");
  }
  setFinderOpen(true);

  function toggleFinder(){ setFinderOpen(finder.classList.contains("is-hidden")); }
  finderToggle.addEventListener("click", toggleFinder);
  finderToggle.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){ e.preventDefault(); toggleFinder(); }
  });

  // =========================
  // Minimap toggle
  // =========================
  function setMinimapOpen(open){
    MINIMAP_OPEN = open;
    mm.wrap.classList.toggle("is-hidden", !open);
    mm.wrap.setAttribute("aria-hidden", open ? "false" : "true");
    mm.toggle.setAttribute("aria-expanded", open ? "true" : "false");
    if(open) updateMinimapRect();
  }
  setMinimapOpen(false);

  mm.toggle.addEventListener("click", ()=> setMinimapOpen(!MINIMAP_OPEN));
  mm.toggle.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){ e.preventDefault(); setMinimapOpen(!MINIMAP_OPEN); }
  });

  window.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      setFinderOpen(false);
      setMinimapOpen(false);
      document.getElementById("sidebar").classList.remove("open");
    }
  });

  // =========================
  // Toast
  // =========================
  function showToast(title, detail, ms=1800){
    const wrap = document.getElementById("toast-wrap");
    const el = document.createElement("div");
    el.className = "toastish";
    el.innerHTML = `<div class="t1">${escapeHtml(title || "")}</div>${detail ? `<div class="t2">${escapeHtml(detail)}</div>` : ""}`;
    wrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    setTimeout(()=>{
      el.classList.remove("show");
      setTimeout(()=> el.remove(), 260);
    }, ms);
  }

  // =========================
  // PAN & ZOOM
  // =========================
  let isDragging=false, lastX=0, lastY=0;
  let tx=0, ty=0, zoom=INITIAL_ZOOM;

  function setTransform(){
    viewport.setAttribute("transform", `translate(${tx}, ${ty}) scale(${zoom})`);
    applyZoomVisibilityRules();
    if(MINIMAP_OPEN) updateMinimapRect();
  }

  function zoomAbout(screenX, screenY, factor){
    const pt = svg.createSVGPoint();
    pt.x = screenX; pt.y = screenY;
    const ctm = viewport.getCTM();
    if(!ctm) return;
    const inv = ctm.inverse();
    const world = pt.matrixTransform(inv);

    const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * factor));
    if(newZoom === zoom) return;

    zoom = newZoom;
    tx = screenX - world.x * zoom;
    ty = screenY - world.y * zoom;
    setTransform();
  }

  function isInteractiveTarget(el){
    return !!(el.closest(".star.major") ||
              el.closest("#finder") ||
              el.closest("#finder-toggle") ||
              el.closest("#sidebar") ||
              el.closest("#ui-overlay") ||
              el.closest("#minimap") ||
              el.closest("#minimap-toggle"));
  }

  sky.addEventListener("mousedown", (e)=>{
    if(e.button !== 0) return;
    if(isInteractiveTarget(e.target)) return;
    isDragging = true;
    sky.classList.add("dragging");
    lastX = e.clientX; lastY = e.clientY;
  });

  window.addEventListener("mousemove", (e)=>{
    if(!isDragging) return;
    tx += (e.clientX - lastX);
    ty += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    setTransform();
  });

  function endDrag(){
    isDragging = false;
    sky.classList.remove("dragging");
  }
  window.addEventListener("mouseup", endDrag);
  window.addEventListener("mouseleave", endDrag);

  sky.addEventListener("wheel", (e)=>{
    e.preventDefault();
    zoomAbout(e.clientX, e.clientY, e.deltaY < 0 ? 1.12 : 0.89);
  }, { passive:false });

  function setupViewBox(){
    const w = window.innerWidth, h = window.innerHeight;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    if(tx === 0 && ty === 0){
      tx = w/2; ty = h/2;
      zoom = INITIAL_ZOOM;
      setTransform();
    }
  }
  window.addEventListener("resize", setupViewBox);
  setupViewBox();

  function applyZoomVisibilityRules(){
    document.querySelectorAll(".const-label").forEach(l=>{
      l.style.display = (zoom <= LABEL_SHOW_ZOOM) ? "" : "none";
    });
  }

  // =========================
  // Projection
  // =========================
  function project(altDeg, azDeg){
    const r = (90 - altDeg) * SKY_SCALE;
    const a = azDeg * Math.PI / 180;
    return { x: r * Math.sin(a), y: -r * Math.cos(a) };
  }

  function centroid(pts){
    const n = pts.length || 1;
    let sx=0, sy=0;
    pts.forEach(p=>{ sx += p.x; sy += p.y; });
    return { x: sx/n, y: sy/n };
  }

  // =========================
  // Hull
  // =========================
  function cross(o, a, b){
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }
  function convexHull(points){
    const uniq = [];
    const seen = new Set();
    for(const p of points){
      const k = `${Math.round(p.x*10)}|${Math.round(p.y*10)}`;
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(p);
    }
    if(uniq.length <= 2) return uniq;
    uniq.sort((p,q)=> p.x === q.x ? p.y - q.y : p.x - q.x);
    const lower = [];
    for(const p of uniq){
      while(lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
      lower.push(p);
    }
    const upper = [];
    for(let i=uniq.length-1; i>=0; i--){
      const p = uniq[i];
      while(upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
      upper.push(p);
    }
    upper.pop(); lower.pop();
    return lower.concat(upper);
  }
  function hullPath(points, pad){
    if(points.length === 0) return "";
    if(points.length === 1){
      const p = points[0];
      const r = pad;
      return `M ${p.x-r} ${p.y} a ${r} ${r} 0 1 0 ${2*r} 0 a ${r} ${r} 0 1 0 ${-2*r} 0`;
    }
    if(points.length === 2){
      const a = points[0], b = points[1];
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      return `M ${a.x + nx*pad} ${a.y + ny*pad} L ${b.x + nx*pad} ${b.y + ny*pad} L ${b.x - nx*pad} ${b.y - ny*pad} L ${a.x - nx*pad} ${a.y - ny*pad} Z`;
    }
    const c = centroid(points);
    const expanded = points.map(p=>{
      const dx = p.x - c.x, dy = p.y - c.y;
      const len = Math.hypot(dx,dy) || 1;
      return { x: p.x + (dx/len)*pad, y: p.y + (dy/len)*pad };
    });
    let d = `M ${expanded[0].x} ${expanded[0].y}`;
    for(let i=1; i<expanded.length; i++) d += ` L ${expanded[i].x} ${expanded[i].y}`;
    d += " Z";
    return d;
  }

  // =========================
  // Nearest point
  // =========================
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function nearestPointOnSegment(p, a, b){
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const denom = abx*abx + aby*aby;
    const t = denom ? clamp((apx*abx + apy*aby) / denom, 0, 1) : 0;
    const x = a.x + abx*t, y = a.y + aby*t;
    const dx = p.x - x, dy = p.y - y;
    return { x, y, d2: dx*dx + dy*dy };
  }
  function nearestPointOnPolylines(p, polylines){
    let best = null;
    for(const line of (polylines || [])){
      for(let i=0; i<line.length-1; i++){
        const cand = nearestPointOnSegment(p, line[i], line[i+1]);
        if(!best || cand.d2 < best.d2) best = cand;
      }
    }
    return best;
  }

  // =========================
  // Focus
  // =========================
  function setFocusConstellation(name){
    if(FOCUSED_CONST === name) return;
    FOCUSED_CONST = name;

    if(name) viewport.classList.add("has-focus");
    else viewport.classList.remove("has-focus");

    document.querySelectorAll(".const-group").forEach(g=>{
      g.classList.toggle("is-focus", name && g.getAttribute("data-const") === name);
    });
    document.querySelectorAll(".const-item").forEach(el=>{
      el.classList.toggle("active", name && el.getAttribute("data-name") === name);
    });

    if(MINIMAP_OPEN) updateMinimapFocus();
  }

  let blurTimer = null;
  function clearFocusSoon(){
    if(blurTimer) clearTimeout(blurTimer);
    blurTimer = setTimeout(()=> setFocusConstellation(null), 120);
  }

  // =========================
  // Sidebar
  // =========================
  const aud = document.getElementById("s-audio");
  function openStar(m){
    document.getElementById("s-name").innerText = m.name || "Star";
    document.getElementById("s-const").innerText = (m.const || "CONSTELLATION").toUpperCase();

    const HIDE_KEYS = new Set([
      "Pitch_Hz","Pan","Loudness","Timbre","Extra_Layers","Mood_Tag",
      "Emotion Code","Tempo (BPM)","Suggested Instrument Set",
      "File","Audio_File","Audio file","Audio",
      "id","Star Name","Constellation",
      "snap_d","_distToLine","snapped"
    ]);

    const KEEP_KEYS = new Set([
      "RA","Dec","RA (hh:mm:ss)","Dec (dd:mm:ss)",
      "Magnitude","Mag",
      "Spectral Type",
      "Binary / Cluster Membership"
    ]);

    const meta = Object.entries(m.meta || {})
      .filter(([k,v]) => v !== null && v !== undefined && String(v).trim() !== "")
      .filter(([k]) => !HIDE_KEYS.has(k))
      .filter(([k]) => KEEP_KEYS.has(k))
      .map(([k,v]) => `<div class="rowish"><span>${escapeHtml(k)}</span><b>${escapeHtml(String(v))}</b></div>`)
      .join("");

    const audioRow = `<div class="rowish"><span>Has audio</span><b>${m.audio ? "Yes" : "No"}</b></div>`;

    document.getElementById("s-meta").innerHTML =
      (meta || `<div class="text-white-50">No astronomy metadata.</div>`) + audioRow;

    if(m.audio){
      aud.src = m.audio;
      aud.style.display = "";
      aud.play().catch(()=>{});
    } else {
      aud.pause();
      aud.removeAttribute("src");
      aud.load();
      aud.style.display = "none";
    }

    document.getElementById("sidebar").classList.add("open");
  }

  function escapeHtml(s){
    return (s ?? "").replace(/[&<>"']/g, ch => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[ch]));
  }

  document.getElementById("closeSide").onclick = ()=>{
    document.getElementById("sidebar").classList.remove("open");
  };

  // =========================
  // Finder list (HIDE 0 AUDIO)
  // =========================
  function buildConstellationList(){
    const list = document.getElementById("const-list");
    const q = (document.getElementById("const-q").value || "").trim().toLowerCase();

    const names = Object.keys(CONST_INFO)
      .filter(n => (CONST_INFO[n]?.audioCount || 0) > 0)          // <-- hide 0 audio
      .sort()
      .filter(n => !q || n.toLowerCase().includes(q));

    list.innerHTML = names.map(n=>{
      const info = CONST_INFO[n];
      return `<div class="const-item" data-name="${escapeHtml(n)}">
        <div>
          <div class="const-name">${escapeHtml(n)}</div>
          <div class="const-count">${info.audioCount} audio</div>
        </div>
        <div class="text-white-50" style="font-weight:950;">›</div>
      </div>`;
    }).join("");

    list.querySelectorAll(".const-item").forEach(el=>{
      const name = el.getAttribute("data-name");
      el.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      el.addEventListener("mouseleave", ()=> clearFocusSoon());
      el.addEventListener("click", ()=> focusConstellation(name));
    });
  }
  document.getElementById("const-q").addEventListener("input", buildConstellationList);

  function focusConstellation(name){
    setFocusConstellation(name);
    const info = CONST_INFO[name];
    if(!info) return;

    const w = window.innerWidth, h = window.innerHeight;
    const pad = 140;

    const bw = Math.max(80, info.maxX - info.minX);
    const bh = Math.max(80, info.maxY - info.minY);

    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, Math.min((w-2*pad)/bw, (h-2*pad)/bh)));
    tx = (w/2) - info.centerX * zoom;
    ty = (h/2) - info.centerY * zoom;
    setTransform();
  }

  function resetView(){
    setFocusConstellation(null);
    tx = window.innerWidth/2;
    ty = window.innerHeight/2;
    zoom = INITIAL_ZOOM;          // MAX zoom-out
    setTransform();
  }
  document.getElementById("btn-reset").onclick = resetView;

  // =========================
  // Render helpers
  // =========================
  function magToR_audio(mag){
    const t = Math.max(-1, Math.min(6, mag ?? 3));
    const r = 10.5 - (t * 1.0);
    return Math.max(3.2, Math.min(12.0, r));
  }
  function lineStarR(){ return 4.2; }

  // =========================
  // MINIMAP mapping (ONLY constellation gold dots)
  // =========================
  function computeWorldBounds(){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    document.querySelectorAll(".const-group").forEach(g=>{
      g.querySelectorAll("line.const-line").forEach(ln=>{
        const x1 = parseFloat(ln.getAttribute("x1")), y1 = parseFloat(ln.getAttribute("y1"));
        const x2 = parseFloat(ln.getAttribute("x2")), y2 = parseFloat(ln.getAttribute("y2"));
        if(Number.isFinite(x1)){ minX=Math.min(minX,x1); maxX=Math.max(maxX,x1); minY=Math.min(minY,y1); maxY=Math.max(maxY,y1); }
        if(Number.isFinite(x2)){ minX=Math.min(minX,x2); maxX=Math.max(maxX,x2); minY=Math.min(minY,y2); maxY=Math.max(maxY,y2); }
      });
      g.querySelectorAll("text.const-label").forEach(t=>{
        const x = parseFloat(t.getAttribute("x")), y = parseFloat(t.getAttribute("y"));
        if(Number.isFinite(x)){ minX=Math.min(minX,x); maxX=Math.max(maxX,x); minY=Math.min(minY,y); maxY=Math.max(maxY,y); }
      });
    });
    if(!Number.isFinite(minX)) return null;
    const pad = 120;
    return { minX:minX-pad, minY:minY-pad, maxX:maxX+pad, maxY:maxY+pad };
  }

  function worldToMini(p){
    if(!WORLD_BOUNDS) return {x:0,y:0};
    const {minX,minY,maxX,maxY} = WORLD_BOUNDS;
    const nx = (p.x - minX) / (maxX - minX || 1);
    const ny = (p.y - minY) / (maxY - minY || 1);
    return { x: nx * mm.W, y: ny * mm.H };
  }

  function updateMinimapConstDots(){
    mm.layer.innerHTML = "";
    if(!WORLD_BOUNDS) return;

    const frag = document.createDocumentFragment();

    // one gold dot per constellation (use label position as center)
    document.querySelectorAll(".const-group").forEach(g=>{
      const name = g.getAttribute("data-const") || "";
      const lbl = g.querySelector("text.const-label");
      if(!lbl) return;

      const x = parseFloat(lbl.getAttribute("x"));
      const y = parseFloat(lbl.getAttribute("y"));
      if(!Number.isFinite(x) || !Number.isFinite(y)) return;

      const p = worldToMini({x,y});
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", p.x);
      c.setAttribute("cy", p.y);
      c.setAttribute("r", 3.0);
      c.setAttribute("class", "mm-const");
      c.setAttribute("data-const", name);
      frag.appendChild(c);
    });

    mm.layer.appendChild(frag);
    updateMinimapFocus();
  }

  function updateMinimapFocus(){
    mm.layer.querySelectorAll(".mm-const").forEach(n=>{
      n.classList.toggle("focus", !!FOCUSED_CONST && n.getAttribute("data-const") === FOCUSED_CONST);
    });
  }

  function currentViewWorldRect(){
    const w = window.innerWidth, h = window.innerHeight;
    const x0 = (0 - tx) / zoom;
    const y0 = (0 - ty) / zoom;
    const x1 = (w - tx) / zoom;
    const y1 = (h - ty) / zoom;
    return {
      minX: Math.min(x0,x1), minY: Math.min(y0,y1),
      maxX: Math.max(x0,x1), maxY: Math.max(y0,y1)
    };
  }

  function updateMinimapRect(){
    if(!WORLD_BOUNDS) return;
    const r = currentViewWorldRect();
    const a = worldToMini({x:r.minX, y:r.minY});
    const b = worldToMini({x:r.maxX, y:r.maxY});
    const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
    const w = Math.max(6, Math.abs(b.x - a.x));
    const h = Math.max(6, Math.abs(b.y - a.y));
    mm.rect.setAttribute("x", x);
    mm.rect.setAttribute("y", y);
    mm.rect.setAttribute("width", w);
    mm.rect.setAttribute("height", h);
  }

  // click minimap to pan
  mm.wrap.addEventListener("click", (e)=>{
    const rect = mm.wrap.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    if(!WORLD_BOUNDS) return;

    const {minX,minY,maxX,maxY} = WORLD_BOUNDS;
    const wx = minX + (sx / rect.width) * (maxX - minX);
    const wy = minY + (sy / rect.height) * (maxY - minY);

    const W = window.innerWidth, H = window.innerHeight;
    tx = (W/2) - wx * zoom;
    ty = (H/2) - wy * zoom;
    setTransform();
  });

  // =========================
  // Main render
  // =========================
  function renderConstellations(){
    groupsLayer.innerHTML = "";
    CONST_INFO = {};

    for(const c of CONSTS){
      const name = c.name;
      const polylines = c.polylines || [];
      const lineStars = c.line_stars || [];
      let audioStars = c.audio_stars || [];

      // SAFETY: if backend ever sends 0-audio constellations, skip
      if(!audioStars || audioStars.length === 0) continue;

      const allLinePts = [];
      const projLines = polylines.map(line=>{
        const pts = line.map(pt=>{
          const p = project(pt.alt, pt.az);
          allLinePts.push(p);
          return p;
        });
        return pts;
      });

      const projLineStars = lineStars.map(s => project(s.alt, s.az));
      const projAudioBase = audioStars.map(s => project(s.alt, s.az));

      const baseForCenter = allLinePts.length ? allLinePts : (projAudioBase.length ? projAudioBase : projLineStars);
      if(!baseForCenter.length) continue;

      const cen = centroid(baseForCenter);

      function spreadPoint(p){
        return {
          x: cen.x * CONST_SPREAD + (p.x - cen.x) * INTRA_SPREAD,
          y: cen.y * CONST_SPREAD + (p.y - cen.y) * INTRA_SPREAD
        };
      }

      const spreadLines = projLines.map(line => line.map(spreadPoint));
      const spreadLineStars = projLineStars.map(spreadPoint);

      let spreadAudio = audioStars.map(s=>{
        const p = spreadPoint(project(s.alt, s.az));
        return {...s, x:p.x, y:p.y};
      });

      if(SNAP_AUDIO_TO_LINES && spreadLines.length){
        const snapDist = SNAP_PX_AT_ZOOM1;
        const keepDist = KEEP_MAX_PX_AT_ZOOM1;

        spreadAudio = spreadAudio
          .map(s=>{
            const p = {x:s.x, y:s.y};
            const best = nearestPointOnPolylines(p, spreadLines);
            if(!best) return { ...s, _distToLine: Infinity };
            const d = Math.sqrt(best.d2);
            if(best.d2 <= snapDist*snapDist){
              return { ...s, x: best.x, y: best.y, snapped: true, snap_d: d, _distToLine: d };
            }
            return { ...s, _distToLine: d };
          })
          .filter(s => (s._distToLine ?? Infinity) <= keepDist);
      }

      // after snapping/keeping, if constellation ends up 0 audio stars, skip it
      if(!spreadAudio || spreadAudio.length === 0) continue;

      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      const allPtsForBounds = [
        ...spreadLines.flat(),
        ...spreadLineStars,
        ...spreadAudio.map(s => ({x:s.x, y:s.y}))
      ];
      allPtsForBounds.forEach(p=>{
        if(!p) return;
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
        maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
      });
      const center2 = { x:(minX+maxX)/2, y:(minY+maxY)/2 };

      CONST_INFO[name] = {
        minX, minY, maxX, maxY,
        centerX:center2.x, centerY:center2.y,
        audioCount: spreadAudio.length,
        lineCount: spreadLineStars.length
      };

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("class", "const-group");
      g.setAttribute("data-const", name);

      const hullPts = [];
      spreadLines.forEach(line=> line.forEach(p=> hullPts.push(p)));
      spreadLineStars.forEach(p=> hullPts.push(p));
      spreadAudio.forEach(s=> hullPts.push({x:s.x, y:s.y}));

      const hull = convexHull(hullPts);

      const hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
      hit.setAttribute("d", hullPath(hull, 22));
      hit.setAttribute("class", "const-hit");
      hit.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      hit.addEventListener("mouseleave", ()=> clearFocusSoon());
      hit.addEventListener("click", ()=> focusConstellation(name));
      g.appendChild(hit);

      for(const line of spreadLines){
        for(let i=0; i<line.length-1; i++){
          const a = line[i], b = line[i+1];
          const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
          ln.setAttribute("x1", a.x); ln.setAttribute("y1", a.y);
          ln.setAttribute("x2", b.x); ln.setAttribute("y2", b.y);
          ln.setAttribute("class", "const-line");
          g.appendChild(ln);
        }
      }

      const lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      lbl.setAttribute("text-anchor", "middle");
      lbl.setAttribute("class", "const-label");
      lbl.setAttribute("x", center2.x);
      lbl.setAttribute("y", center2.y);
      lbl.textContent = name;
      g.appendChild(lbl);

      for(const p of spreadLineStars){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", p.x);
        cc.setAttribute("cy", p.y);
        cc.setAttribute("r", lineStarR());
        cc.setAttribute("class", "star line");
        g.appendChild(cc);
      }

      for(const s of spreadAudio){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", s.x);
        cc.setAttribute("cy", s.y);
        cc.setAttribute("r", magToR_audio(s.mag));
        cc.setAttribute("class", "star major");
        cc.addEventListener("pointerdown", (e)=> e.stopPropagation());
        cc.addEventListener("mousedown", (e)=> e.stopPropagation());
        cc.addEventListener("click", (e)=>{
          e.stopPropagation();
          openStar(s);
        });
        g.appendChild(cc);
      }

      groupsLayer.appendChild(g);
    }

    buildConstellationList();
    applyZoomVisibilityRules();

    WORLD_BOUNDS = computeWorldBounds();
    if(WORLD_BOUNDS){
      updateMinimapConstDots();
      if(MINIMAP_OPEN) updateMinimapRect();
    }
  }

  // =========================
  // Time controls + fetch
  // =========================
  function seasonDateUTC(season){
    const y = new Date().getFullYear();
    const map = { spring:[3,21], summer:[6,21], fall:[9,22], winter:[12,21] };
    const md = map[season] || map.winter;
    const hour = parseInt(document.getElementById("hour").value || "21", 10);
    return new Date(y, md[0]-1, md[1], hour, 0, 0).toISOString();
  }

  async function updateSky(lat, lon, ts){
    const btn = document.getElementById("btn-go");
    const prev = btn.innerText;
    btn.disabled = true;
    btn.innerText = "Loading…";

    const url =
      `/api/sky?lat=${encodeURIComponent(lat)}` +
      `&lon=${encodeURIComponent(lon)}` +
      `&ts=${encodeURIComponent(ts)}` +
      `&min_alt=${encodeURIComponent(MIN_ALT)}`;

    try{
      const r = await fetch(url);
      const d = await r.json();

      CONSTS = d.constellations || [];
      renderConstellations();
      resetView();

      const cCount = d.counts?.constellations_sent ?? CONSTS.length;
      const aRows  = d.counts?.audio_csv_rows ?? "";
      showToast("Sky updated", `Constellations: ${cCount}${aRows!=="" ? ` · Audio rows: ${aRows}` : ""}`, 1700);
    } catch(err){
      showToast("Failed to load sky", "Check /api/sky response", 2200);
      console.error(err);
    } finally{
      btn.disabled = false;
      btn.innerText = prev;
    }
  }

  document.getElementById("btn-loc").onclick = ()=>{
    if(navigator.geolocation) navigator.geolocation.getCurrentPosition((pos)=>{
      document.getElementById("lat").value = pos.coords.latitude.toFixed(6);
      document.getElementById("lon").value = pos.coords.longitude.toFixed(6);
    });
  };

  document.getElementById("btn-go").onclick = ()=>{
    updateSky(
      document.getElementById("lat").value,
      document.getElementById("lon").value,
      seasonDateUTC(document.getElementById("season").value)
    );
  };

  (function init(){
    updateSky(37.5665, 126.9780, seasonDateUTC("winter"));
  })();
</script>
</body>
</html>
