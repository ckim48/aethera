<!-- templates/sky.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Celestial Navigation - Constellations Only</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --panel: rgba(10,12,18,.82);
      --panel2: rgba(10,12,18,.92);
      --text: rgba(255,255,255,.90);
      --muted: rgba(255,255,255,.58);
      --glow: rgba(255,255,255,.55);
      --line: rgba(197,160,89,.65);
      --lineSoft: rgba(197,160,89,.18);
    }

    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
    #sky-container{
      position:fixed; inset:0;
      background-image:url('/static/images/dark_sky.jpg');
      background-size:cover; background-position:center;
      cursor:grab;
    }
    #sky-container.dragging{ cursor:grabbing; }
    svg{ width:100%; height:100%; display:block; }

    /* Only stars we use */
    .star.line{
      fill: rgba(255,255,255,.88);
      filter: drop-shadow(0 0 8px rgba(255,255,255,.18));
      opacity:.72;
      pointer-events:none;
    }

    .star.major{
      fill:#fff;
      filter: drop-shadow(0 0 10px var(--glow));
      cursor:pointer;
      opacity:.95;
      transition: opacity .18s ease;
      pointer-events:auto;
    }

    #view-port.has-focus .const-group:not(.is-focus) .const-line{ opacity:.08; }
    #view-port.has-focus .const-group:not(.is-focus) .const-label{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.major{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.line{ opacity:.10; }

    .const-line{
      stroke: var(--lineSoft);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
      opacity: .70;
      pointer-events:none;
      transition: stroke .22s ease, opacity .22s ease, filter .22s ease;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.18));
    }
    .const-group.is-focus .const-line{
      stroke: var(--line);
      opacity: 1;
      filter: drop-shadow(0 0 16px rgba(197,160,89,.35));
    }

    .const-label{
      fill: var(--muted);
      font-weight: 900;
      letter-spacing: .20em;
      text-transform: uppercase;
      pointer-events:none;
      user-select:none;
      paint-order: stroke fill;
      stroke: rgba(0,0,0,.55);
      stroke-width: 3px;
      transition: opacity .18s ease;
    }
    .const-group.is-focus .const-label{ opacity: 1; fill: rgba(255,255,255,.78); }

    .const-hit{
      fill: rgba(255,255,255,.0001);
      stroke: rgba(255,255,255,0);
      pointer-events: all;
      cursor: pointer;
    }

    /* Finder + Sidebar */
    #finder{
      position:fixed; top:18px; left:18px;
      width:300px; max-width: calc(100vw - 36px);
      background: var(--panel);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      z-index:2000;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    #finder .head{ padding:14px 14px 10px 14px; border-bottom:1px solid rgba(255,255,255,.10); }
    #finder .title{
      color:var(--text); font-weight:950; letter-spacing:.02em; font-size:1.02rem;
      margin:0 0 10px 0; display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    #finder .smallhint{ color:var(--muted); font-size:.82rem; margin:8px 0 0 0; }
    #finder .body{ padding: 12px; max-height: calc(100vh - 220px); overflow:auto; }
    #finder input{
      background: rgba(255,255,255,.06) !important;
      border: 1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
    }
    #finder input::placeholder{ color: rgba(255,255,255,.55); }

    .const-item{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 10px; border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      margin:8px 0; cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .const-item:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
    }
    .const-item.active{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
    }
    .const-name{ color:var(--text); font-weight:900; letter-spacing:.02em; }
    .const-count{ color:var(--muted); font-size:.85rem; }

    #sidebar{
      position:fixed; right:-520px; top:0; bottom:0;
      width:480px; max-width: calc(100vw - 36px);
      background: var(--panel2);
      backdrop-filter: blur(22px);
      border-left:1px solid rgba(255,255,255,.12);
      z-index:2200;
      transition: .55s cubic-bezier(.16,1,.3,1);
      padding:24px 22px;
      color:#fff;
      overflow:auto;
    }
    #sidebar.open{ right:0; }
    #closeSide{
      cursor:pointer; opacity:.65; font-size:1.8rem; line-height:1;
      width:44px; height:44px; border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    #s-name{ font-weight: 950; margin:14px 0 6px 0; }
    #s-const{ color:#7fd3ff; letter-spacing:.22em; text-transform:uppercase; font-size:.82rem; margin:0 0 14px 0; }
    #s-meta .rowish{
      display:flex; justify-content:space-between; gap:14px;
      padding:10px 0; border-bottom: 1px solid rgba(255,255,255,.08);
      font-size:.92rem;
    }
    #s-meta .rowish b{ font-weight:950; }
    #s-audio{ width:100%; filter: invert(1); margin-top:12px; }

    /* Controls (move to right) */
    #ui-overlay{
      position:fixed; bottom:18px; right:18px;
      z-index:2100;
      width:min(980px, calc(100vw - 36px));
      background: var(--panel);
      backdrop-filter: blur(18px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 10px 12px;
      display:flex; gap:10px; align-items:center;
      flex-wrap: wrap;
      justify-content: flex-end;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    #ui-overlay .ctl{
      background: rgba(255,255,255,.06) !important;
      border:1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      border-radius: 999px !important;
      padding: 10px 14px;
    }
    #ui-overlay .btn{
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      letter-spacing:.02em;
      white-space:nowrap;
    }

    /* Toast popup */
    #toast-wrap{
      position:fixed; top:18px; right:18px;
      z-index:2300;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none;
    }
    .toastish{
      pointer-events:none;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(12px);
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      transform: translateY(-6px);
      opacity: 0;
      transition: opacity .22s ease, transform .22s ease;
      max-width: min(520px, calc(100vw - 36px));
      line-height: 1.35;
    }
    .toastish.show{ opacity: 1; transform: translateY(0); }
    .toastish .t1{ font-weight: 950; }
    .toastish .t2{ color: rgba(255,255,255,.70); font-size:.9rem; margin-top:2px; }
  </style>
</head>

<body>
  <div id="sky-container">
    <svg id="sky-svg">
      <g id="view-port">
        <g id="groups-layer"></g>
      </g>
    </svg>
  </div>

  <div id="finder">
    <div class="head">
      <div class="title">
        <span>Constellation Finder</span>
        <button id="btn-reset" class="btn btn-sm btn-outline-light" style="border-radius:999px;">Reset</button>
      </div>
      <input id="const-q" class="form-control" placeholder="Search constellation (e.g., Orion)" />
      <p class="smallhint">Hover a constellation to highlight. Click audio stars.</p>
    </div>
    <div class="body" id="const-list"></div>
  </div>

  <div id="sidebar">
    <div class="d-flex justify-content-end">
      <div id="closeSide" title="Close">&times;</div>
    </div>
    <h1 id="s-name">Star</h1>
    <p id="s-const">CONSTELLATION</p>
    <audio id="s-audio" controls></audio>
    <div id="s-meta" class="mt-3"></div>
  </div>

  <!-- Removed the status card completely -->
  <!-- <div id="status">Loading…</div> -->

  <div id="ui-overlay">
    <button id="btn-loc" class="btn btn-outline-light">Use my location</button>
    <input id="lat" class="ctl form-control" style="max-width: 170px" placeholder="Lat" value="37.5665" />
    <input id="lon" class="ctl form-control" style="max-width: 170px" placeholder="Lon" value="126.9780" />

    <select id="season" class="ctl form-select" style="max-width: 180px">
      <option value="spring">Spring (Mar 21)</option>
      <option value="summer">Summer (Jun 21)</option>
      <option value="fall">Fall (Sep 22)</option>
      <option value="winter" selected>Winter (Dec 21)</option>
    </select>

    <input id="hour" type="number" min="0" max="23" class="ctl form-control d-none" style="max-width: 120px" value="21" title="Local hour" />
    <button id="btn-go" class="btn btn-light">Show sky</button>
  </div>

  <!-- Popup container -->
  <div id="toast-wrap" aria-live="polite" aria-atomic="true"></div>

<script>
  // =========================
  // TUNE
  // =========================
  const SKY_SCALE = 34;
  const CONST_SPREAD = 2.6;
  const INTRA_SPREAD = 1.0;

  const ZOOM_MIN = 0.35, ZOOM_MAX = 9.0;
  const LABEL_SHOW_ZOOM = 0.85;

  const MIN_ALT = -8;

  // Audio-star alignment rules:
  // 1) If close to any constellation line, snap onto the line (so it sits exactly on the shape).
  // 2) If far from the lines, remove it (prevents floating outliers like your Lyra screenshot).
  const SNAP_AUDIO_TO_LINES = true;
  const SNAP_PX_AT_ZOOM1 = 26;          // snap if <= 26px (at zoom=1)
  const KEEP_MAX_PX_AT_ZOOM1 = 36;      // keep only if <= 36px (at zoom=1)

  // =========================
  // STATE
  // =========================
  let CONSTS = [];
  let CONST_INFO = {};
  let FOCUSED_CONST = null;

  const svg = document.getElementById("sky-svg");
  const viewport = document.getElementById("view-port");
  const groupsLayer = document.getElementById("groups-layer");
  const sky = document.getElementById("sky-container");

  // =========================
  // Tiny toast popup
  // =========================
  function showToast(title, detail, ms=1800){
    const wrap = document.getElementById("toast-wrap");
    const el = document.createElement("div");
    el.className = "toastish";
    el.innerHTML = `<div class="t1">${escapeHtml(title || "")}</div>${detail ? `<div class="t2">${escapeHtml(detail)}</div>` : ""}`;
    wrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    setTimeout(()=>{
      el.classList.remove("show");
      setTimeout(()=> el.remove(), 260);
    }, ms);
  }

  // =========================
  // PAN & ZOOM
  // =========================
  let isDragging=false, lastX=0, lastY=0;
  let tx=0, ty=0, zoom=1.0;

  function setTransform(){
    viewport.setAttribute("transform", `translate(${tx}, ${ty}) scale(${zoom})`);
    applyZoomVisibilityRules();
  }

  function zoomAbout(screenX, screenY, factor){
    const pt = svg.createSVGPoint();
    pt.x = screenX; pt.y = screenY;
    const ctm = viewport.getCTM();
    if(!ctm) return;
    const inv = ctm.inverse();
    const world = pt.matrixTransform(inv);

    const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * factor));
    if(newZoom === zoom) return;

    zoom = newZoom;
    tx = screenX - world.x * zoom;
    ty = screenY - world.y * zoom;
    setTransform();
  }

  function isInteractiveTarget(el){
    return !!(el.closest(".star.major") ||
              el.closest("#finder") ||
              el.closest("#sidebar") ||
              el.closest("#ui-overlay"));
  }

  sky.addEventListener("mousedown", (e)=>{
    if(e.button !== 0) return;
    if(isInteractiveTarget(e.target)) return;
    isDragging = true;
    sky.classList.add("dragging");
    lastX = e.clientX; lastY = e.clientY;
  });

  window.addEventListener("mousemove", (e)=>{
    if(!isDragging) return;
    tx += (e.clientX - lastX);
    ty += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    setTransform();
  });

  function endDrag(){
    isDragging = false;
    sky.classList.remove("dragging");
  }
  window.addEventListener("mouseup", endDrag);
  window.addEventListener("mouseleave", endDrag);

  sky.addEventListener("wheel", (e)=>{
    e.preventDefault();
    zoomAbout(e.clientX, e.clientY, e.deltaY < 0 ? 1.12 : 0.89);
  }, { passive:false });

  function setupViewBox(){
    const w = window.innerWidth, h = window.innerHeight;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    if(tx === 0 && ty === 0){
      tx = w/2; ty = h/2; zoom = 1.0;
      setTransform();
    }
  }
  window.addEventListener("resize", setupViewBox);
  setupViewBox();

  function applyZoomVisibilityRules(){
    document.querySelectorAll(".const-label").forEach(l=>{
      l.style.display = (zoom <= LABEL_SHOW_ZOOM) ? "" : "none";
    });
  }

  // =========================
  // Projection
  // =========================
  function project(altDeg, azDeg){
    const r = (90 - altDeg) * SKY_SCALE;
    const a = azDeg * Math.PI / 180;
    return { x: r * Math.sin(a), y: -r * Math.cos(a) };
  }

  function centroid(pts){
    const n = pts.length || 1;
    let sx=0, sy=0;
    pts.forEach(p=>{ sx += p.x; sy += p.y; });
    return { x: sx/n, y: sy/n };
  }

  // =========================
  // Hull for hit area
  // =========================
  function cross(o, a, b){
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }
  function convexHull(points){
    const uniq = [];
    const seen = new Set();
    for(const p of points){
      const k = `${Math.round(p.x*10)}|${Math.round(p.y*10)}`;
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(p);
    }
    if(uniq.length <= 2) return uniq;
    uniq.sort((p,q)=> p.x === q.x ? p.y - q.y : p.x - q.x);
    const lower = [];
    for(const p of uniq){
      while(lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
      lower.push(p);
    }
    const upper = [];
    for(let i=uniq.length-1; i>=0; i--){
      const p = uniq[i];
      while(upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
      upper.push(p);
    }
    upper.pop(); lower.pop();
    return lower.concat(upper);
  }
  function hullPath(points, pad){
    if(points.length === 0) return "";
    if(points.length === 1){
      const p = points[0];
      const r = pad;
      return `M ${p.x-r} ${p.y} a ${r} ${r} 0 1 0 ${2*r} 0 a ${r} ${r} 0 1 0 ${-2*r} 0`;
    }
    if(points.length === 2){
      const a = points[0], b = points[1];
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      return `M ${a.x + nx*pad} ${a.y + ny*pad} L ${b.x + nx*pad} ${b.y + ny*pad} L ${b.x - nx*pad} ${b.y - ny*pad} L ${a.x - nx*pad} ${a.y - ny*pad} Z`;
    }
    const c = centroid(points);
    const expanded = points.map(p=>{
      const dx = p.x - c.x, dy = p.y - c.y;
      const len = Math.hypot(dx,dy) || 1;
      return { x: p.x + (dx/len)*pad, y: p.y + (dy/len)*pad };
    });
    let d = `M ${expanded[0].x} ${expanded[0].y}`;
    for(let i=1; i<expanded.length; i++) d += ` L ${expanded[i].x} ${expanded[i].y}`;
    d += " Z";
    return d;
  }

  // =========================
  // Nearest point on line (for snapping + filtering outliers)
  // =========================
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function nearestPointOnSegment(p, a, b){
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const denom = abx*abx + aby*aby;
    const t = denom ? clamp((apx*abx + apy*aby) / denom, 0, 1) : 0;
    const x = a.x + abx*t, y = a.y + aby*t;
    const dx = p.x - x, dy = p.y - y;
    return { x, y, d2: dx*dx + dy*dy };
  }

  function nearestPointOnPolylines(p, polylines){
    let best = null;
    for(const line of (polylines || [])){
      for(let i=0; i<line.length-1; i++){
        const cand = nearestPointOnSegment(p, line[i], line[i+1]);
        if(!best || cand.d2 < best.d2) best = cand;
      }
    }
    return best;
  }

  // =========================
  // Focus
  // =========================
  function setFocusConstellation(name){
    if(FOCUSED_CONST === name) return;
    FOCUSED_CONST = name;

    if(name) viewport.classList.add("has-focus");
    else viewport.classList.remove("has-focus");

    document.querySelectorAll(".const-group").forEach(g=>{
      g.classList.toggle("is-focus", name && g.getAttribute("data-const") === name);
    });
    document.querySelectorAll(".const-item").forEach(el=>{
      el.classList.toggle("active", name && el.getAttribute("data-name") === name);
    });
  }

  let blurTimer = null;
  function clearFocusSoon(){
    if(blurTimer) clearTimeout(blurTimer);
    blurTimer = setTimeout(()=> setFocusConstellation(null), 120);
  }

  // =========================
  // Sidebar
  // =========================
  const aud = document.getElementById("s-audio");
function openStar(m){
  document.getElementById("s-name").innerText = m.name || "Star";
  document.getElementById("s-const").innerText = (m.const || "CONSTELLATION").toUpperCase();

  // Hide sonification / audio-design / debug fields
  const HIDE_KEYS = new Set([
    // sonification + audio design
    "Pitch_Hz","Pan","Loudness","Timbre","Extra_Layers","Mood_Tag",
    "Emotion Code","Tempo (BPM)","Suggested Instrument Set",
    // file-ish
    "File","Audio_File","Audio file","Audio",
    // internal-ish
    "id","Star Name","Constellation",
    // debug
    "snap_d","_distToLine","snapped"
  ]);

  // Allow-list (preferred): only show astronomy-related fields
  const KEEP_KEYS = new Set([
    "RA","Dec","RA (hh:mm:ss)","Dec (dd:mm:ss)",
    "Magnitude","Mag",
    "Spectral Type",
    "Binary / Cluster Membership"
  ]);

  const meta = Object.entries(m.meta || {})
    .filter(([k,v]) => v !== null && v !== undefined && String(v).trim() !== "")
    .filter(([k]) => !HIDE_KEYS.has(k))
    .filter(([k]) => KEEP_KEYS.has(k))   // astronomy only
    .map(([k,v]) => `<div class="rowish"><span>${escapeHtml(k)}</span><b>${escapeHtml(String(v))}</b></div>`)
    .join("");

  // Keep ONLY "Has audio" + the player (no Audio URL / exists / snap dist rows)
  const audioRow = `<div class="rowish"><span>Has audio</span><b>${m.audio ? "Yes" : "No"}</b></div>`;

  document.getElementById("s-meta").innerHTML =
    (meta || `<div class="text-white-50">No astronomy metadata.</div>`) + audioRow;

  if(m.audio){
    aud.src = m.audio;
    aud.style.display = "";
    aud.play().catch(()=>{});
  } else {
    aud.pause();
    aud.removeAttribute("src");
    aud.load();
    aud.style.display = "none";
  }

  document.getElementById("sidebar").classList.add("open");
}


  function escapeHtml(s){
    return (s ?? "").replace(/[&<>"']/g, ch => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[ch]));
  }

  document.getElementById("closeSide").onclick = ()=>{
    document.getElementById("sidebar").classList.remove("open");
  };

  // =========================
  // Finder list
  // =========================
  function buildConstellationList(){
    const list = document.getElementById("const-list");
    const q = (document.getElementById("const-q").value || "").trim().toLowerCase();

    const names = Object.keys(CONST_INFO).sort().filter(n => !q || n.toLowerCase().includes(q));
    list.innerHTML = names.map(n=>{
      const info = CONST_INFO[n];
      return `<div class="const-item" data-name="${escapeHtml(n)}">
        <div>
          <div class="const-name">${escapeHtml(n)}</div>
          <div class="const-count">${info.audioCount} audio stars</div>
        </div>
        <div class="text-white-50" style="font-weight:950;">›</div>
      </div>`;
    }).join("");

    list.querySelectorAll(".const-item").forEach(el=>{
      const name = el.getAttribute("data-name");
      el.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      el.addEventListener("mouseleave", ()=> clearFocusSoon());
      el.addEventListener("click", ()=> focusConstellation(name));
    });
  }
  document.getElementById("const-q").addEventListener("input", buildConstellationList);

  function focusConstellation(name){
    setFocusConstellation(name);
    const info = CONST_INFO[name];
    if(!info) return;

    const w = window.innerWidth, h = window.innerHeight;
    const pad = 140;

    const bw = Math.max(80, info.maxX - info.minX);
    const bh = Math.max(80, info.maxY - info.minY);

    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, Math.min((w-2*pad)/bw, (h-2*pad)/bh)));
    tx = (w/2) - info.centerX * zoom;
    ty = (h/2) - info.centerY * zoom;
    setTransform();
  }

  function resetView(){
    setFocusConstellation(null);
    tx = window.innerWidth/2;
    ty = window.innerHeight/2;
    zoom = 1.0;
    setTransform();
  }
  document.getElementById("btn-reset").onclick = resetView;

  // =========================
  // Render
  // =========================
  function magToR_audio(mag){
    const t = Math.max(-1, Math.min(6, mag ?? 3));
    const r = 10.5 - (t * 1.0);
    return Math.max(3.2, Math.min(12.0, r));
  }
  function lineStarR(){
    return 4.2;
  }

  function renderConstellations(){
    groupsLayer.innerHTML = "";
    CONST_INFO = {};

    for(const c of CONSTS){
      const name = c.name;
      const polylines = c.polylines || [];
      const lineStars = c.line_stars || [];
      let audioStars = c.audio_stars || [];

      // project lines
      const allLinePts = [];
      const projLines = polylines.map(line=>{
        const pts = line.map(pt=>{
          const p = project(pt.alt, pt.az);
          allLinePts.push(p);
          return p;
        });
        return pts;
      });

      // project line stars and audio stars (for hull + centroid)
      const projLineStars = lineStars.map(s => project(s.alt, s.az));
      const projAudioBase = audioStars.map(s => project(s.alt, s.az));

      const baseForCenter = allLinePts.length ? allLinePts : (projAudioBase.length ? projAudioBase : projLineStars);
      if(!baseForCenter.length) continue;

      const cen = centroid(baseForCenter);

      function spreadPoint(p){
        return {
          x: cen.x * CONST_SPREAD + (p.x - cen.x) * INTRA_SPREAD,
          y: cen.y * CONST_SPREAD + (p.y - cen.y) * INTRA_SPREAD
        };
      }

      const spreadLines = projLines.map(line => line.map(spreadPoint));
      const spreadLineStars = projLineStars.map(spreadPoint);

      // spread audio stars
      let spreadAudio = audioStars.map(s=>{
        const p = spreadPoint(project(s.alt, s.az));
        return {...s, x:p.x, y:p.y};
      });

      // SNAP + FILTER OUTLIERS (IMPORTANT)
      if(SNAP_AUDIO_TO_LINES && spreadLines.length){
        const snapDist = SNAP_PX_AT_ZOOM1;
        const keepDist = KEEP_MAX_PX_AT_ZOOM1;

        spreadAudio = spreadAudio
          .map(s=>{
            const p = {x:s.x, y:s.y};
            const best = nearestPointOnPolylines(p, spreadLines);
            if(!best) return { ...s, _distToLine: Infinity };

            const d = Math.sqrt(best.d2);

            if(best.d2 <= snapDist*snapDist){
              return { ...s, x: best.x, y: best.y, snapped: true, snap_d: d, _distToLine: d };
            }
            return { ...s, _distToLine: d };
          })
          .filter(s => (s._distToLine ?? Infinity) <= keepDist);
      }

      // bounds
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      const allPtsForBounds = [
        ...spreadLines.flat(),
        ...spreadLineStars,
        ...spreadAudio.map(s => ({x:s.x, y:s.y}))
      ];
      allPtsForBounds.forEach(p=>{
        if(!p) return;
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
        maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
      });
      const center2 = { x:(minX+maxX)/2, y:(minY+maxY)/2 };

      CONST_INFO[name] = {
        minX, minY, maxX, maxY,
        centerX:center2.x, centerY:center2.y,
        audioCount: spreadAudio.length,
        lineCount: spreadLineStars.length
      };

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("class", "const-group");
      g.setAttribute("data-const", name);

      // hit hull
      const hullPts = [];
      spreadLines.forEach(line=> line.forEach(p=> hullPts.push(p)));
      spreadLineStars.forEach(p=> hullPts.push(p));
      spreadAudio.forEach(s=> hullPts.push({x:s.x, y:s.y}));

      const hull = convexHull(hullPts);

      const hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
      hit.setAttribute("d", hullPath(hull, 22));
      hit.setAttribute("class", "const-hit");
      hit.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      hit.addEventListener("mouseleave", ()=> clearFocusSoon());
      hit.addEventListener("click", ()=> focusConstellation(name));
      g.appendChild(hit);

      // draw lines
      for(const line of spreadLines){
        for(let i=0; i<line.length-1; i++){
          const a = line[i], b = line[i+1];
          const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
          ln.setAttribute("x1", a.x); ln.setAttribute("y1", a.y);
          ln.setAttribute("x2", b.x); ln.setAttribute("y2", b.y);
          ln.setAttribute("class", "const-line");
          g.appendChild(ln);
        }
      }

      // label
      const lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      lbl.setAttribute("text-anchor", "middle");
      lbl.setAttribute("class", "const-label");
      lbl.setAttribute("x", center2.x);
      lbl.setAttribute("y", center2.y);
      lbl.textContent = name;
      g.appendChild(lbl);

      // draw constellation line-stars
      for(const p of spreadLineStars){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", p.x);
        cc.setAttribute("cy", p.y);
        cc.setAttribute("r", lineStarR());
        cc.setAttribute("class", "star line");
        g.appendChild(cc);
      }

      // draw audio stars
      for(const s of spreadAudio){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", s.x);
        cc.setAttribute("cy", s.y);
        cc.setAttribute("r", magToR_audio(s.mag));
        cc.setAttribute("class", "star major");
        cc.addEventListener("pointerdown", (e)=> e.stopPropagation());
        cc.addEventListener("mousedown", (e)=> e.stopPropagation());
        cc.style.cursor = "pointer";
        cc.addEventListener("click", (e)=>{
          e.stopPropagation();
          openStar(s);
        });
        g.appendChild(cc);
      }

      groupsLayer.appendChild(g);
    }

    buildConstellationList();
    applyZoomVisibilityRules();
  }

  // =========================
  // Time controls + fetch
  // =========================
  function seasonDateUTC(season){
    const y = new Date().getFullYear();
    const map = { spring:[3,21], summer:[6,21], fall:[9,22], winter:[12,21] };
    const md = map[season] || map.winter;
    const hour = parseInt(document.getElementById("hour").value || "21", 10);
    return new Date(y, md[0]-1, md[1], hour, 0, 0).toISOString();
  }

  async function updateSky(lat, lon, ts){
    const btn = document.getElementById("btn-go");
    const prev = btn.innerText;
    btn.disabled = true;
    btn.innerText = "Loading…";

    const url =
      `/api/sky?lat=${encodeURIComponent(lat)}` +
      `&lon=${encodeURIComponent(lon)}` +
      `&ts=${encodeURIComponent(ts)}` +
      `&min_alt=${encodeURIComponent(MIN_ALT)}`;

    try{
      const r = await fetch(url);
      const d = await r.json();

      CONSTS = d.constellations || [];
      renderConstellations();
      resetView();

      // popup when done
      const cCount = d.counts?.constellations_sent ?? CONSTS.length;
      const aRows  = d.counts?.audio_csv_rows ?? "";
      showToast("Sky updated", `Constellations: ${cCount}${aRows!=="" ? ` · Audio rows: ${aRows}` : ""}`, 1700);
    } catch(err){
      showToast("Failed to load sky", "Check /api/sky response", 2200);
      console.error(err);
    } finally{
      btn.disabled = false;
      btn.innerText = prev;
    }
  }

  document.getElementById("btn-loc").onclick = ()=>{
    if(navigator.geolocation) navigator.geolocation.getCurrentPosition((pos)=>{
      document.getElementById("lat").value = pos.coords.latitude.toFixed(6);
      document.getElementById("lon").value = pos.coords.longitude.toFixed(6);
    });
  };

  document.getElementById("btn-go").onclick = ()=>{
    updateSky(
      document.getElementById("lat").value,
      document.getElementById("lon").value,
      seasonDateUTC(document.getElementById("season").value)
    );
  };

  (function init(){
    updateSky(37.5665, 126.9780, seasonDateUTC("winter"));
  })();
</script>
</body>
</html>
