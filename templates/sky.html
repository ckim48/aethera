<!-- templates/sky.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Celestial Navigation - Constellations Only</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="icon" type="image/png" sizes="32x32" href="../static/images/favicon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="../static/images/apple-touch-icon.png">

  <style>
    :root{
      --panel: rgba(10,12,18,.82);
      --panel2: rgba(10,12,18,.92);
      --text: rgba(255,255,255,.90);
      --muted: rgba(255,255,255,.58);
      --glow: rgba(255,255,255,.55);
      --line: rgba(197,160,89,.65);
      --lineSoft: rgba(197,160,89,.18);
      --gold: rgba(197,160,89,.92);
    }

    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
    #sky-container{
      position:fixed; inset:0;
      background-image:url('/static/images/dark_sky.jpg');
      background-size:cover; background-position:center;
      cursor:grab;
    }
    #sky-container.dragging{ cursor:grabbing; }
    svg{ width:100%; height:100%; display:block; }

    /* Stars */
    .star.line{
      fill: rgba(255,255,255,.88);
      filter: drop-shadow(0 0 8px rgba(255,255,255,.18));
      opacity:.72;
      pointer-events:none;
    }
    .star.major{
      fill:#fff;
      filter: drop-shadow(0 0 10px var(--glow));
      cursor:pointer;
      opacity:.95;
      transition: opacity .18s ease;
      pointer-events:auto;
    }

    /* Focus dimming */
    #view-port.has-focus .const-group:not(.is-focus) .const-line{ opacity:.08; }
    #view-port.has-focus .const-group:not(.is-focus) .const-label{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.major{ opacity:.10; }
    #view-port.has-focus .const-group:not(.is-focus) .star.line{ opacity:.10; }

    .const-line{
      stroke: var(--lineSoft);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
      opacity: .70;
      pointer-events:none;
      transition: stroke .22s ease, opacity .22s ease, filter .22s ease;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.18));
    }
    .const-group.is-focus .const-line{
      stroke: var(--line);
      opacity: 1;
      filter: drop-shadow(0 0 16px rgba(197,160,89,.35));
    }

    .const-label{
      fill: var(--muted);
      font-weight: 900;
      letter-spacing: .20em;
      text-transform: uppercase;
      pointer-events:none;
      user-select:none;
      paint-order: stroke fill;
      stroke: rgba(0,0,0,.55);
      stroke-width: 3px;
      transition: opacity .18s ease;
    }
    .const-group.is-focus .const-label{ opacity: 1; fill: rgba(255,255,255,.78); }

    .const-hit{
      fill: rgba(255,255,255,.0001);
      stroke: rgba(255,255,255,0);
      pointer-events: all;
      cursor: pointer;
    }

    /* =========================
       TOP RIGHT CONTROLS (compact)
       ========================= */
    #ui-overlay{
      position:fixed;
      top:12px;
      right:12px;
      z-index:2100;
      background: var(--panel);
      backdrop-filter: blur(16px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 7px 8px;
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap: nowrap;
      justify-content:flex-end;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      max-width: calc(100vw - 24px);
    }
    #ui-overlay .ctl{
      background: rgba(255,255,255,.06) !important;
      border:1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      border-radius: 999px !important;
      padding: 6px 9px;
      font-size: .84rem;
      line-height: 1.05;
      height: 32px;
      box-shadow: none !important;
    }
    #ui-overlay .btn{
      border-radius: 999px;
      padding: 6px 9px;
      font-weight: 900;
      letter-spacing:.01em;
      white-space:nowrap;
      font-size: .84rem;
      line-height: 1.05;
      height: 32px;
    }
    #ui-overlay #lat, #ui-overlay #lon{ width: 112px; }
    #ui-overlay #season{ width: 148px; }

    @media (max-width: 560px){
      #ui-overlay{ flex-wrap: wrap; border-radius: 16px; padding: 10px; }
      #ui-overlay #lat, #ui-overlay #lon{ width: 44vw; min-width: 120px; }
      #ui-overlay #season{ width: 52vw; min-width: 150px; }
    }

    /* =========================
       Finder -> LEFT (compact) + toggle button
       ========================= */
    #finder-toggle{
      position:fixed;
      top:12px;
      left:12px;
      z-index:2050;
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:7px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(14px);
      color: rgba(255,255,255,.92);
      box-shadow: 0 10px 40px rgba(0,0,0,.40);
      cursor:pointer;
      user-select:none;
      font-weight: 950;
      letter-spacing:.01em;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      height: 32px;
      font-size: .84rem;
      line-height: 1;
    }
    #finder-toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }
    #finder-toggle .pill{
      width:9px; height:9px; border-radius:999px;
      background: var(--gold);
      box-shadow: 0 0 14px rgba(197,160,89,.45);
      flex: 0 0 auto;
    }

    #finder{
      position:fixed;
      top:48px; left:12px;
      width:270px;
      max-width: calc(100vw - 24px);
      background: var(--panel);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      z-index:2000;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      transition: transform .55s cubic-bezier(.16,1,.3,1), opacity .25s ease;
      transform-origin: top left;
    }
    #finder.is-hidden{
      opacity: 0;
      transform: translateX(-10px) scale(.95);
      pointer-events:none;
    }

    #finder .head{
      padding:10px 10px 8px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    #finder .title{
      color:var(--text);
      font-weight:950;
      letter-spacing:.01em;
      font-size:.95rem;
      margin:0 0 8px 0;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    #finder .smallhint{
      color:var(--muted);
      font-size:.78rem;
      margin:6px 0 0 0;
      line-height:1.25;
    }
    #finder .body{
      padding: 8px 10px 10px;
      max-height: calc(100vh - 180px);
      overflow:auto;
    }
    #finder input{
      background: rgba(255,255,255,.06) !important;
      border: 1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      height: 32px;
      padding: 6px 10px;
      font-size:.84rem;
      border-radius: 12px;
    }
    #finder input::placeholder{ color: rgba(255,255,255,.55); }

    .const-item{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:8px 9px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      margin:7px 0;
      cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .const-item:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
    }
    .const-item.active{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
    }
    .const-name{ color:var(--text); font-weight:900; letter-spacing:.01em; font-size:.90rem; }
    .const-count{ color:var(--muted); font-size:.80rem; }

    /* =========================
       MINIMAP (right bottom) + toggle button
       ========================= */
    #minimap-toggle{
      position:fixed;
      right:12px;
      bottom:12px;
      z-index:2150;
      width: 34px;
      height: 34px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(14px);
      box-shadow: 0 10px 40px rgba(0,0,0,.40);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      color: rgba(255,255,255,.92);
      font-weight: 950;
      line-height: 1;
    }
    #minimap-toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }

    #minimap{
      position:fixed;
      right:12px;
      bottom:54px;
      width: 220px;
      height: 160px;
      max-width: calc(100vw - 24px);
      background: rgba(0,0,0,.34);
      backdrop-filter: blur(14px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      z-index:2140;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      overflow:hidden;
      transform-origin: bottom right;
      transition: transform .55s cubic-bezier(.16,1,.3,1), opacity .25s ease;
    }
    #minimap.is-hidden{
      opacity: 0;
      transform: translateY(10px) scale(.95);
      pointer-events:none;
    }
    #minimap svg{ width:100%; height:100%; display:block; }
    .mm-bg{ fill: rgba(0,0,0,.12); }

    .mm-const{
      fill: rgba(197,160,89,.86);
      opacity: .98;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.25));
    }
    .mm-const.focus{
      fill: rgba(255,255,255,.95);
      opacity: 1;
      filter: drop-shadow(0 0 14px rgba(255,255,255,.25));
    }

    .mm-rect{
      fill: rgba(127,211,255,.08);
      stroke: rgba(127,211,255,.55);
      stroke-width: 1;
      vector-effect: non-scaling-stroke;
      rx: 6; ry: 6;
    }
    .mm-hint{
      position:absolute;
      left:10px;
      bottom:8px;
      font-size:.74rem;
      color: rgba(255,255,255,.72);
      letter-spacing:.01em;
      user-select:none;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.55);
    }

    /* Sidebar */
    #sidebar{
      position:fixed; right:-520px; top:0; bottom:0;
      width:480px; max-width: calc(100vw - 36px);
      background: var(--panel2);
      backdrop-filter: blur(22px);
      border-left:1px solid rgba(255,255,255,.12);
      z-index:2200;
      transition: .55s cubic-bezier(.16,1,.3,1);
      padding:24px 22px;
      color:#fff;
      overflow:auto;
    }
    #sidebar.open{ right:0; }
    #closeSide{
      cursor:pointer; opacity:.65; font-size:1.8rem; line-height:1;
      width:44px; height:44px; border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    #s-name{ font-weight: 950; margin:14px 0 6px 0; }
    #s-const{ color:#7fd3ff; letter-spacing:.22em; text-transform:uppercase; font-size:.82rem; margin:0 0 14px 0; }
    #s-meta .rowish{
      display:flex; justify-content:space-between; gap:14px;
      padding:10px 0; border-bottom: 1px solid rgba(255,255,255,.08);
      font-size:.92rem;
    }
    #s-meta .rowish b{ font-weight:950; }
    #s-audio{ width:100%; filter: invert(1); margin-top:12px; }

    /* Toast */
    #toast-wrap{
      position:fixed; top:60px; right:12px;
      z-index:2300;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none;
    }

    .toastish{
      pointer-events:none;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(12px);
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
      transform: translateY(-6px);
      opacity: 0;
      transition: opacity .22s ease, transform .22s ease;
      max-width: min(520px, calc(100vw - 24px));
      line-height: 1.35;
      overflow: hidden;
      position: relative;
    }
    .toastish.show{ opacity: 1; transform: translateY(0); }

    .toastish .t1{ font-weight: 950; }
    .toastish .t2{ color: rgba(255,255,255,.70); font-size:.9rem; margin-top:2px; }

    .toastish.is-error{
      background: rgba(120, 20, 20, .42);
      border-color: rgba(255, 90, 90, .28);
      box-shadow: 0 12px 44px rgba(0,0,0,.45), 0 0 0 1px rgba(255, 90, 90, .10) inset;
    }
    .toastish.is-error::before{
      content:"";
      position:absolute;
      left:0; top:0; bottom:0;
      width: 4px;
      background: rgba(255, 90, 90, .92);
    }
    .toastish.is-error .t1{ color: rgba(255, 235, 235, .96); }
    .toastish.is-error .t2{ color: rgba(255, 210, 210, .78); }

    /* =====================================================
       REPORT floating button + bottom-right modal panel
       ===================================================== */
    #report-toggle{
      position:fixed;
      right:56px;
      bottom:12px;
      z-index:2160;
      height:34px;
      padding:0 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.32);
      backdrop-filter: blur(14px);
      box-shadow: 0 10px 40px rgba(0,0,0,.40);
      color: rgba(255,255,255,.92);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-weight:950;
      font-size:.84rem;
      line-height:1;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      white-space:nowrap;
    }
    #report-toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }
    #report-toggle .dot{
      width:8px; height:8px; border-radius:999px;
      background: var(--gold);
      box-shadow: 0 0 14px rgba(197,160,89,.45);
    }

    #report-modal{
      position:fixed;
      right:12px;
      bottom:54px;
      width: 520px;
      max-width: calc(100vw - 24px);
      max-height: min(64vh, 560px);
      background: var(--panel2);
      backdrop-filter: blur(18px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 16px;
      z-index:2190;
      box-shadow: 0 12px 60px rgba(0,0,0,.55);
      overflow:hidden;
      transform-origin: bottom right;
      transition: transform .55s cubic-bezier(.16,1,.3,1), opacity .25s ease;
    }
    #report-modal.is-hidden{
      opacity:0;
      transform: translateY(10px) scale(.96);
      pointer-events:none;
    }
    #report-modal .r-head{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    #report-modal .r-title{
      margin:0;
      font-weight:950;
      letter-spacing:.01em;
      font-size:.98rem;
      color: rgba(255,255,255,.92);
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    #report-modal .r-title small{
      color: rgba(255,255,255,.62);
      font-weight:800;
      letter-spacing:.02em;
      font-size:.78rem;
      white-space:nowrap;
    }
    #report-modal .r-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex: 0 0 auto;
    }
    #report-modal .r-btn{
      height:30px;
      padding: 0 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.92);
      font-weight:900;
      font-size:.80rem;
      cursor:pointer;
    }
    #report-modal .r-btn:hover{
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.22);
    }
    #report-modal .r-body{
      padding: 10px 12px 12px;
      overflow:auto;
      max-height: calc(min(64vh, 560px) - 52px);
    }
    .r-row{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 14px;
      padding: 10px 10px;
      margin: 8px 0;
    }
    .r-row .r-name{
      font-weight:950;
      letter-spacing:.01em;
      color: rgba(255,255,255,.92);
      margin-bottom:4px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .r-row .r-badge{
      font-size:.72rem;
      font-weight:950;
      letter-spacing:.08em;
      text-transform:uppercase;
      border-radius:999px;
      padding: 3px 8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.78);
      white-space:nowrap;
    }
    .r-row.is-ok .r-badge{
      border-color: rgba(197,160,89,.22);
      background: rgba(197,160,89,.10);
      color: rgba(255,255,255,.92);
    }
    .r-row.is-bad .r-badge{
      border-color: rgba(255,90,90,.22);
      background: rgba(255,90,90,.08);
      color: rgba(255,235,235,.92);
    }
    .r-row .r-sentence{
      color: rgba(255,255,255,.74);
      font-size:.90rem;
      line-height:1.35;
      margin:0;
      word-break: break-word;
    }

    /* =========================
       PAGE LOADER (full-screen)
       ========================= */
    .page-loader{
      position:fixed; inset:0; z-index:5000;
      display:flex; align-items:center; justify-content:center;
      background:
        radial-gradient(900px 520px at 20% 10%, rgba(197,160,89,.16), transparent 60%),
        radial-gradient(700px 480px at 80% 30%, rgba(127,211,255,.10), transparent 62%),
        rgba(0,0,0,.70);
      backdrop-filter: blur(12px);
      transition: opacity .25s ease, visibility .25s ease;
    }
    .page-loader.hide{ opacity:0; visibility:hidden; pointer-events:none; }

    .loader-card{
      width:min(520px, calc(100vw - 28px));
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(10,12,18,.82);
      box-shadow: 0 18px 80px rgba(0,0,0,.55);
      padding: 18px 18px 16px;
      text-align:center;
    }
    .loader-title{
      color: rgba(255,255,255,.92);
      font-weight: 950;
      letter-spacing: .01em;
      margin-top: 12px;
      font-size: 1.02rem;
    }
    .loader-sub{
      color: rgba(255,255,255,.62);
      margin-top: 6px;
      font-size: .88rem;
      line-height: 1.35;
    }
    .loader-ring{
      width: 54px; height: 54px;
      border-radius: 999px;
      border: 4px solid rgba(255,255,255,.14);
      border-top-color: rgba(197,160,89,.92);
      margin: 0 auto;
      animation: spin 1.0s linear infinite;
      box-shadow: 0 0 22px rgba(197,160,89,.15);
    }
    @keyframes spin{ to{ transform: rotate(360deg);} }
  </style>
</head>

<body>
  <!-- PAGE LOADER -->
  <div id="pageLoader" class="page-loader" aria-live="polite" aria-busy="true">
    <div class="loader-card">
      <div class="loader-ring" aria-hidden="true"></div>
      <div class="loader-title">Loading sky…</div>
      <div class="loader-sub" id="loaderSub">Preparing constellations and audio stars</div>
    </div>
  </div>

  <div id="sky-container">
    <svg id="sky-svg">
      <g id="view-port">
        <g id="groups-layer"></g>
      </g>
    </svg>
  </div>

  <!-- TOP RIGHT CONTROLS -->
  <div id="ui-overlay">
    <button id="btn-loc" class="btn btn-outline-light">Use my location</button>

    <input id="lat" type="text" class="ctl form-control" placeholder="Lat" value="37.5665" />
    <input id="lon" type="text" class="ctl form-control" placeholder="Lon" value="126.9780" />

    <select id="season" class="ctl form-select">
      <option value="spring">Spring (Mar 21)</option>
      <option value="summer">Summer (Jun 21)</option>
      <option value="fall">Fall (Sep 22)</option>
      <option value="winter" selected>Winter (Dec 21)</option>
    </select>
    <input id="hour" type="number" min="0" max="23" class="ctl form-control d-none" value="21" title="Local hour" />
    <button id="btn-go" class="btn btn-light">Show sky</button>
  </div>

  <!-- LEFT FINDER TOGGLE -->
  <div id="finder-toggle" title="Toggle Finder" role="button" tabindex="0" aria-controls="finder" aria-expanded="true">
    <span class="pill"></span>
    <span>Finder</span>
  </div>

  <!-- LEFT FINDER -->
  <div id="finder">
    <div class="head">
      <div class="title">
        <span>Constellation Finder</span>
        <button id="btn-reset" class="btn btn-sm btn-outline-light" style="border-radius:999px; padding:4px 8px; height:28px; font-size:.78rem;">Reset</button>
      </div>
      <input id="const-q" class="form-control" placeholder="Search (e.g., Orion)" />
      <p class="smallhint">Hover to highlight · click to zoom · click audio stars.</p>
    </div>
    <div class="body" id="const-list"></div>
  </div>

  <!-- MINIMAP TOGGLE -->
  <div id="minimap-toggle" title="Toggle minimap" role="button" tabindex="0" aria-controls="minimap" aria-expanded="false">◎</div>

  <!-- REPORT TOGGLE (right bottom) -->
  <div id="report-toggle" title="Season visibility report" role="button" tabindex="0" aria-controls="report-modal" aria-expanded="false">
    <span class="dot"></span>
    <span>Report</span>
  </div>

  <!-- MINIMAP PANEL -->
  <div id="minimap" class="is-hidden" aria-hidden="true">
    <svg id="mm-svg" viewBox="0 0 220 160" preserveAspectRatio="none">
      <rect class="mm-bg" x="0" y="0" width="220" height="160"></rect>
      <g id="mm-consts"></g>
      <rect id="mm-rect" class="mm-rect" x="70" y="50" width="70" height="60"></rect>
    </svg>
    <div class="mm-hint">Minimap · dots = constellations</div>
  </div>

  <!-- REPORT MODAL (bottom-right) -->
  <div id="report-modal" class="is-hidden" aria-hidden="true">
    <div class="r-head">
      <div class="r-title">
        <span>Season Visibility Report</span>
        <small id="report-sub">Season · Lat/Lon</small>
      </div>
      <div class="r-actions">
        <button class="r-btn" id="report-refresh" title="Refresh report">Refresh</button>
        <button class="r-btn" id="report-close" title="Close report">Close</button>
      </div>
    </div>
    <div class="r-body" id="report-body">
      <div class="text-white-50">Click “Refresh” to load the report.</div>
    </div>
  </div>

  <div id="sidebar">
    <div class="d-flex justify-content-end">
      <div id="closeSide" title="Close">&times;</div>
    </div>
    <h1 id="s-name">Star</h1>
    <p id="s-const">CONSTELLATION</p>
    <audio id="s-audio" controls></audio>
    <div id="s-meta" class="mt-3"></div>
  </div>

  <div id="toast-wrap" aria-live="polite" aria-atomic="true"></div>

<script>
  // =========================
  // TUNE
  // =========================
  const SKY_SCALE = 34;
  const CONST_SPREAD = 2.6;
  const INTRA_SPREAD = 1.0;

  const ZOOM_MIN = 0.35, ZOOM_MAX = 9.0;
  const LABEL_SHOW_ZOOM = 0.85;

  const MIN_ALT = -8;

  const SNAP_AUDIO_TO_LINES = true;
  const SNAP_PX_AT_ZOOM1 = 26;
  const KEEP_MAX_PX_AT_ZOOM1 = 36;

  // Initial view: MAX zoom-out
  const INITIAL_ZOOM = ZOOM_MIN;

  // =========================
  // STATE
  // =========================
  let CONSTS = [];
  let CONST_INFO = {};
  let FOCUSED_CONST = null;

  // NEW: Visibility set (season/location driven)
  let VISIBLE_CONST_SET = null; // null => show all
  let LAST_REPORT_PAYLOAD = null;

  const svg = document.getElementById("sky-svg");
  const viewport = document.getElementById("view-port");
  const groupsLayer = document.getElementById("groups-layer");
  const sky = document.getElementById("sky-container");

  // minimap
  const mm = {
    wrap: document.getElementById("minimap"),
    toggle: document.getElementById("minimap-toggle"),
    layer: document.getElementById("mm-consts"),
    rect: document.getElementById("mm-rect"),
    W: 220, H: 160
  };
  let MINIMAP_OPEN = false;
  let WORLD_BOUNDS = null;

  // =========================
  // Loader helpers
  // =========================
  const pageLoader = document.getElementById("pageLoader");
  const loaderSub  = document.getElementById("loaderSub");
  function showLoader(msg){
    if(loaderSub && msg) loaderSub.textContent = msg;
    pageLoader?.classList.remove("hide");
    pageLoader?.setAttribute("aria-busy","true");
  }
  function hideLoader(){
    pageLoader?.classList.add("hide");
    pageLoader?.setAttribute("aria-busy","false");
  }

  // =========================
  // Finder toggle
  // =========================
  const finder = document.getElementById("finder");
  const finderToggle = document.getElementById("finder-toggle");

  function setFinderOpen(open){
    finder.classList.toggle("is-hidden", !open);
    finderToggle.setAttribute("aria-expanded", open ? "true" : "false");
  }
  setFinderOpen(true);

  function toggleFinder(){ setFinderOpen(finder.classList.contains("is-hidden")); }
  finderToggle.addEventListener("click", toggleFinder);
  finderToggle.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){ e.preventDefault(); toggleFinder(); }
  });

  // =========================
  // Minimap toggle
  // =========================
  function setMinimapOpen(open){
    MINIMAP_OPEN = open;
    mm.wrap.classList.toggle("is-hidden", !open);
    mm.wrap.setAttribute("aria-hidden", open ? "false" : "true");
    mm.toggle.setAttribute("aria-expanded", open ? "true" : "false");
    if(open) updateMinimapRect();
  }
  setMinimapOpen(false);

  mm.toggle.addEventListener("click", ()=> setMinimapOpen(!MINIMAP_OPEN));
  mm.toggle.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){ e.preventDefault(); setMinimapOpen(!MINIMAP_OPEN); }
  });

  window.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      setFinderOpen(false);
      setMinimapOpen(false);
      setReportOpen(false);
      document.getElementById("sidebar").classList.remove("open");
    }
  });

  // =========================
  // Toast
  // =========================
  function escapeHtml(s){
    return (s ?? "").replace(/[&<>"']/g, ch => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[ch]));
  }

  function showToast(title, detail, ms=1800, type="info"){
    const wrap = document.getElementById("toast-wrap");
    const el = document.createElement("div");
    el.className = "toastish" + (type === "error" ? " is-error" : "");
    el.innerHTML =
      `<div class="t1">${escapeHtml(title || "")}</div>` +
      (detail ? `<div class="t2">${escapeHtml(detail)}</div>` : "");
    wrap.appendChild(el);
    requestAnimationFrame(()=> el.classList.add("show"));
    setTimeout(()=>{
      el.classList.remove("show");
      setTimeout(()=> el.remove(), 260);
    }, ms);
  }

  function markInvalid(latBad, lonBad, msg){
    const latEl = document.getElementById("lat");
    const lonEl = document.getElementById("lon");
    latEl.classList.toggle("is-invalid", !!latBad);
    lonEl.classList.toggle("is-invalid", !!lonBad);
    showToast("Invalid coordinates", msg, 2600, "error");
  }

  // =========================
  // Coord validation (ONLY when updating sky)
  // =========================
  function clearCoordInvalid(){
    document.getElementById("lat").classList.remove("is-invalid");
    document.getElementById("lon").classList.remove("is-invalid");
  }

  function readLatLonForUpdate(){
    const latEl = document.getElementById("lat");
    const lonEl = document.getElementById("lon");

    clearCoordInvalid();

    const latStr = String(latEl.value ?? "").trim();
    const lonStr = String(lonEl.value ?? "").trim();

    if(latStr === "" || lonStr === ""){
      markInvalid(latStr === "", lonStr === "", "Latitude/longitude are required.");
      return null;
    }

    const lat = Number(latStr);
    const lon = Number(lonStr);

    const latNum = Number.isFinite(lat);
    const lonNum = Number.isFinite(lon);

    if(!latNum || !lonNum){
      markInvalid(!latNum, !lonNum, "Latitude/longitude must be valid numbers.");
      return null;
    }

    const latBad = (lat < -90 || lat > 90);
    const lonBad = (lon < -180 || lon > 180);

    if(latBad || lonBad){
      markInvalid(latBad, lonBad, "Latitude must be -90..90. Longitude must be -180..180.");
      return null;
    }

    return { lat, lon };
  }

  // =========================
  // PAN & ZOOM
  // =========================
  let isDragging=false, lastX=0, lastY=0;
  let tx=0, ty=0, zoom=INITIAL_ZOOM;

  function setTransform(){
    viewport.setAttribute("transform", `translate(${tx}, ${ty}) scale(${zoom})`);
    applyZoomVisibilityRules();
    if(MINIMAP_OPEN) updateMinimapRect();
  }

  function zoomAbout(screenX, screenY, factor){
    const pt = svg.createSVGPoint();
    pt.x = screenX; pt.y = screenY;
    const ctm = viewport.getCTM();
    if(!ctm) return;
    const inv = ctm.inverse();
    const world = pt.matrixTransform(inv);

    const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * factor));
    if(newZoom === zoom) return;

    zoom = newZoom;
    tx = screenX - world.x * zoom;
    ty = screenY - world.y * zoom;
    setTransform();
  }

  function isInteractiveTarget(el){
    return !!(el.closest(".star.major") ||
              el.closest("#finder") ||
              el.closest("#finder-toggle") ||
              el.closest("#sidebar") ||
              el.closest("#ui-overlay") ||
              el.closest("#minimap") ||
              el.closest("#minimap-toggle") ||
              el.closest("#report-modal") ||
              el.closest("#report-toggle"));
  }

  sky.addEventListener("mousedown", (e)=>{
    if(e.button !== 0) return;
    if(isInteractiveTarget(e.target)) return;
    isDragging = true;
    sky.classList.add("dragging");
    lastX = e.clientX; lastY = e.clientY;
  });

  window.addEventListener("mousemove", (e)=>{
    if(!isDragging) return;
    tx += (e.clientX - lastX);
    ty += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    setTransform();
  });

  function endDrag(){
    isDragging = false;
    sky.classList.remove("dragging");
  }
  window.addEventListener("mouseup", endDrag);
  window.addEventListener("mouseleave", endDrag);

  sky.addEventListener("wheel", (e)=>{
    e.preventDefault();
    zoomAbout(e.clientX, e.clientY, e.deltaY < 0 ? 1.12 : 0.89);
  }, { passive:false });

  function setupViewBox(){
    const w = window.innerWidth, h = window.innerHeight;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    if(tx === 0 && ty === 0){
      tx = w/2; ty = h/2;
      zoom = INITIAL_ZOOM;
      setTransform();
    }
  }
  window.addEventListener("resize", setupViewBox);
  setupViewBox();

function applyZoomVisibilityRules(){
  document.querySelectorAll(".const-label").forEach(l=>{
    l.style.display = "";
  });
}


  // =========================
  // Projection
  // =========================
  function project(altDeg, azDeg){
    const r = (90 - altDeg) * SKY_SCALE;
    const a = azDeg * Math.PI / 180;
    return { x: r * Math.sin(a), y: -r * Math.cos(a) };
  }

  function centroid(pts){
    const n = pts.length || 1;
    let sx=0, sy=0;
    pts.forEach(p=>{ sx += p.x; sy += p.y; });
    return { x: sx/n, y: sy/n };
  }

  // =========================
  // Hull
  // =========================
  function cross(o, a, b){
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }
  function convexHull(points){
    const uniq = [];
    const seen = new Set();
    for(const p of points){
      const k = `${Math.round(p.x*10)}|${Math.round(p.y*10)}`;
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(p);
    }
    if(uniq.length <= 2) return uniq;
    uniq.sort((p,q)=> p.x === q.x ? p.y - q.y : p.x - q.x);
    const lower = [];
    for(const p of uniq){
      while(lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
      lower.push(p);
    }
    const upper = [];
    for(let i=uniq.length-1; i>=0; i--){
      const p = uniq[i];
      while(upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
      upper.push(p);
    }
    upper.pop(); lower.pop();
    return lower.concat(upper);
  }
  function hullPath(points, pad){
    if(points.length === 0) return "";
    if(points.length === 1){
      const p = points[0];
      const r = pad;
      return `M ${p.x-r} ${p.y} a ${r} ${r} 0 1 0 ${2*r} 0 a ${r} ${r} 0 1 0 ${-2*r} 0`;
    }
    if(points.length === 2){
      const a = points[0], b = points[1];
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      return `M ${a.x + nx*pad} ${a.y + ny*pad} L ${b.x + nx*pad} ${b.y + ny*pad} L ${b.x - nx*pad} ${b.y - ny*pad} L ${a.x - nx*pad} ${a.y - ny*pad} Z`;
    }
    const c = centroid(points);
    const expanded = points.map(p=>{
      const dx = p.x - c.x, dy = p.y - c.y;
      const len = Math.hypot(dx,dy) || 1;
      return { x: p.x + (dx/len)*pad, y: p.y + (dy/len)*pad };
    });
    let d = `M ${expanded[0].x} ${expanded[0].y}`;
    for(let i=1; i<expanded.length; i++) d += ` L ${expanded[i].x} ${expanded[i].y}`;
    d += " Z";
    return d;
  }

  // =========================
  // Nearest point
  // =========================
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function nearestPointOnSegment(p, a, b){
    const abx = b.x - a.x, aby = b.y - a.y;
    const apx = p.x - a.x, apy = p.y - a.y;
    const denom = abx*abx + aby*aby;
    const t = denom ? clamp((apx*abx + apy*aby) / denom, 0, 1) : 0;
    const x = a.x + abx*t, y = a.y + aby*t;
    const dx = p.x - x, dy = p.y - y;
    return { x, y, d2: dx*dx + dy*dy };
  }
  function nearestPointOnPolylines(p, polylines){
    let best = null;
    for(const line of (polylines || [])){
      for(let i=0; i<line.length-1; i++){
        const cand = nearestPointOnSegment(p, line[i], line[i+1]);
        if(!best || cand.d2 < best.d2) best = cand;
      }
    }
    return best;
  }

  // =========================
  // Focus
  // =========================
  function setFocusConstellation(name){
    if(FOCUSED_CONST === name) return;
    FOCUSED_CONST = name;

    if(name) viewport.classList.add("has-focus");
    else viewport.classList.remove("has-focus");

    document.querySelectorAll(".const-group").forEach(g=>{
      g.classList.toggle("is-focus", name && g.getAttribute("data-const") === name);
    });
    document.querySelectorAll(".const-item").forEach(el=>{
      el.classList.toggle("active", name && el.getAttribute("data-name") === name);
    });

    if(MINIMAP_OPEN) updateMinimapFocus();
  }

  let blurTimer = null;
  function clearFocusSoon(){
    if(blurTimer) clearTimeout(blurTimer);
    blurTimer = setTimeout(()=> setFocusConstellation(null), 120);
  }

  // =========================
  // Sidebar
  // =========================
  const aud = document.getElementById("s-audio");
  function openStar(m){
    document.getElementById("s-name").innerText = m.name || "Star";
    document.getElementById("s-const").innerText = (m.const || "CONSTELLATION").toUpperCase();

    const HIDE_KEYS = new Set([
      "Pitch_Hz","Pan","Loudness","Timbre","Extra_Layers","Mood_Tag",
      "Emotion Code","Tempo (BPM)","Suggested Instrument Set",
      "File","Audio_File","Audio file","Audio",
      "id","Star Name","Constellation",
      "snap_d","_distToLine","snapped"
    ]);

    const KEEP_KEYS = new Set([
      "RA","Dec","RA (hh:mm:ss)","Dec (dd:mm:ss)",
      "Magnitude","Mag",
      "Spectral Type",
      "Binary / Cluster Membership"
    ]);

    const meta = Object.entries(m.meta || {})
      .filter(([k,v]) => v !== null && v !== undefined && String(v).trim() !== "")
      .filter(([k]) => !HIDE_KEYS.has(k))
      .filter(([k]) => KEEP_KEYS.has(k))
      .map(([k,v]) => `<div class="rowish"><span>${escapeHtml(k)}</span><b>${escapeHtml(String(v))}</b></div>`)
      .join("");

    const audioRow = `<div class="rowish"><span>Has audio</span><b>${m.audio ? "Yes" : "No"}</b></div>`;

    document.getElementById("s-meta").innerHTML =
      (meta || `<div class="text-white-50">No astronomy metadata.</div>`) + audioRow;

    if(m.audio){
      aud.src = m.audio;
      aud.style.display = "";
      aud.play().catch(()=>{});
    } else {
      aud.pause();
      aud.removeAttribute("src");
      aud.load();
      aud.style.display = "none";
    }

    document.getElementById("sidebar").classList.add("open");
  }

  document.getElementById("closeSide").onclick = ()=>{
    document.getElementById("sidebar").classList.remove("open");
  };

  // =========================
  // Finder list (HIDE 0 AUDIO)
  // (hidden constellations never enter CONST_INFO, so they also vanish here)
  // =========================
  function buildConstellationList(){
    const list = document.getElementById("const-list");
    const q = (document.getElementById("const-q").value || "").trim().toLowerCase();

    const names = Object.keys(CONST_INFO)
      .filter(n => (CONST_INFO[n]?.audioCount || 0) > 0)
      .sort()
      .filter(n => !q || n.toLowerCase().includes(q));

    list.innerHTML = names.map(n=>{
      const info = CONST_INFO[n];
      return `<div class="const-item" data-name="${escapeHtml(n)}">
        <div>
          <div class="const-name">${escapeHtml(n)}</div>
          <div class="const-count">${info.audioCount} audio</div>
        </div>
        <div class="text-white-50" style="font-weight:950;">›</div>
      </div>`;
    }).join("");

    list.querySelectorAll(".const-item").forEach(el=>{
      const name = el.getAttribute("data-name");
      el.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      el.addEventListener("mouseleave", ()=> clearFocusSoon());
      el.addEventListener("click", ()=> focusConstellation(name));
    });
  }
  document.getElementById("const-q").addEventListener("input", buildConstellationList);

  function focusConstellation(name){
    setFocusConstellation(name);
    const info = CONST_INFO[name];
    if(!info) return;

    const w = window.innerWidth, h = window.innerHeight;
    const pad = 140;

    const bw = Math.max(80, info.maxX - info.minX);
    const bh = Math.max(80, info.maxY - info.minY);

    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, Math.min((w-2*pad)/bw, (h-2*pad)/bh)));
    tx = (w/2) - info.centerX * zoom;
    ty = (h/2) - info.centerY * zoom;
    setTransform();
  }

  function resetView(){
    setFocusConstellation(null);
    tx = window.innerWidth/2;
    ty = window.innerHeight/2;
    zoom = INITIAL_ZOOM;
    setTransform();
  }
  document.getElementById("btn-reset").onclick = resetView;

  // =========================
  // Render helpers
  // =========================
  function magToR_audio(mag){
    const t = Math.max(-1, Math.min(6, mag ?? 3));
    const r = 10.5 - (t * 1.0);
    return Math.max(3.2, Math.min(12.0, r));
  }
  function lineStarR(){ return 4.2; }

  // =========================
  // MINIMAP mapping (ONLY constellation gold dots)
  // =========================
  function computeWorldBounds(){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    document.querySelectorAll(".const-group").forEach(g=>{
      g.querySelectorAll("line.const-line").forEach(ln=>{
        const x1 = parseFloat(ln.getAttribute("x1")), y1 = parseFloat(ln.getAttribute("y1"));
        const x2 = parseFloat(ln.getAttribute("x2")), y2 = parseFloat(ln.getAttribute("y2"));
        if(Number.isFinite(x1)){ minX=Math.min(minX,x1); maxX=Math.max(maxX,x1); minY=Math.min(minY,y1); maxY=Math.max(maxY,y1); }
        if(Number.isFinite(x2)){ minX=Math.min(minX,x2); maxX=Math.max(maxX,x2); minY=Math.min(minY,y2); maxY=Math.max(maxY,y2); }
      });
      g.querySelectorAll("text.const-label").forEach(t=>{
        const x = parseFloat(t.getAttribute("x")), y = parseFloat(t.getAttribute("y"));
        if(Number.isFinite(x)){ minX=Math.min(minX,x); maxX=Math.max(maxX,x); minY=Math.min(minY,y); maxY=Math.max(maxY,y); }
      });
    });
    if(!Number.isFinite(minX)) return null;
    const pad = 120;
    return { minX:minX-pad, minY:minY-pad, maxX:maxX+pad, maxY:maxY+pad };
  }

  function worldToMini(p){
    if(!WORLD_BOUNDS) return {x:0,y:0};
    const {minX,minY,maxX,maxY} = WORLD_BOUNDS;
    const nx = (p.x - minX) / (maxX - minX || 1);
    const ny = (p.y - minY) / (maxY - minY || 1);
    return { x: nx * mm.W, y: ny * mm.H };
  }

  function updateMinimapConstDots(){
    mm.layer.innerHTML = "";
    if(!WORLD_BOUNDS) return;

    const frag = document.createDocumentFragment();

    document.querySelectorAll(".const-group").forEach(g=>{
      const name = g.getAttribute("data-const") || "";
      const lbl = g.querySelector("text.const-label");
      if(!lbl) return;

      const x = parseFloat(lbl.getAttribute("x"));
      const y = parseFloat(lbl.getAttribute("y"));
      if(!Number.isFinite(x) || !Number.isFinite(y)) return;

      const p = worldToMini({x,y});
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", p.x);
      c.setAttribute("cy", p.y);
      c.setAttribute("r", 3.0);
      c.setAttribute("class", "mm-const");
      c.setAttribute("data-const", name);
      frag.appendChild(c);
    });

    mm.layer.appendChild(frag);
    updateMinimapFocus();
  }

  function updateMinimapFocus(){
    mm.layer.querySelectorAll(".mm-const").forEach(n=>{
      n.classList.toggle("focus", !!FOCUSED_CONST && n.getAttribute("data-const") === FOCUSED_CONST);
    });
  }

  function currentViewWorldRect(){
    const w = window.innerWidth, h = window.innerHeight;
    const x0 = (0 - tx) / zoom;
    const y0 = (0 - ty) / zoom;
    const x1 = (w - tx) / zoom;
    const y1 = (h - ty) / zoom;
    return {
      minX: Math.min(x0,x1), minY: Math.min(y0,y1),
      maxX: Math.max(x0,x1), maxY: Math.max(y0,y1)
    };
  }

  function updateMinimapRect(){
    if(!WORLD_BOUNDS) return;
    const r = currentViewWorldRect();
    const a = worldToMini({x:r.minX, y:r.minY});
    const b = worldToMini({x:r.maxX, y:r.maxY});
    const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
    const w = Math.max(6, Math.abs(b.x - a.x));
    const h = Math.max(6, Math.abs(b.y - a.y));
    mm.rect.setAttribute("x", x);
    mm.rect.setAttribute("y", y);
    mm.rect.setAttribute("width", w);
    mm.rect.setAttribute("height", h);
  }

  mm.wrap.addEventListener("click", (e)=>{
    const rect = mm.wrap.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    if(!WORLD_BOUNDS) return;

    const {minX,minY,maxX,maxY} = WORLD_BOUNDS;
    const wx = minX + (sx / rect.width) * (maxX - minX);
    const wy = minY + (sy / rect.height) * (maxY - minY);

    const W = window.innerWidth, H = window.innerHeight;
    tx = (W/2) - wx * zoom;
    ty = (H/2) - wy * zoom;
    setTransform();
  });

  // =========================
  // REPORT modal logic
  // =========================
  const report = {
    toggle: document.getElementById("report-toggle"),
    modal: document.getElementById("report-modal"),
    close: document.getElementById("report-close"),
    refresh: document.getElementById("report-refresh"),
    body: document.getElementById("report-body"),
    sub: document.getElementById("report-sub"),
    open: false,
    loading: false
  };

  function setReportOpen(open){
    report.open = open;
    report.modal.classList.toggle("is-hidden", !open);
    report.modal.setAttribute("aria-hidden", open ? "false" : "true");
    report.toggle.setAttribute("aria-expanded", open ? "true" : "false");
  }
  setReportOpen(false);

  report.toggle.addEventListener("click", ()=>{
    setReportOpen(!report.open);
    if(report.open) loadReport(); // auto-load on open
  });
  report.toggle.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){
      e.preventDefault();
      setReportOpen(!report.open);
      if(report.open) loadReport();
    }
  });

  report.close.addEventListener("click", ()=> setReportOpen(false));
  report.refresh.addEventListener("click", loadReport);

  function reportRowHTML(it){
    const cls = it.show ? "r-row is-ok" : "r-row is-bad";
    const badge = it.show ? "SHOW" : "HIDE";
    return `
      <div class="${cls}">
        <div class="r-name">
          <span>${escapeHtml(it.name || "")}</span>
          <span class="r-badge">${badge}</span>
        </div>
        <p class="r-sentence">${escapeHtml(it.sentence || "")}</p>
      </div>
    `;
  }

  function visibilitySetFromReportPayload(d){
    const items = d?.items || [];
    const set = new Set();
    for(const it of items){
      if(it && it.name && it.show) set.add(it.name);
    }
    return set;
  }

  async function fetchSeasonVisibility(lat, lon, season){
    // You can tune these once you like
    const minAlt = 10.0;
    const maxMag = 4.5;
    const minStars = 1;

    const url =
      `/api/constellation_report?lat=${encodeURIComponent(lat)}` +
      `&lon=${encodeURIComponent(lon)}` +
      `&season=${encodeURIComponent(season)}` +
      `&min_alt=${encodeURIComponent(minAlt)}` +
      `&max_mag=${encodeURIComponent(maxMag)}` +
      `&min_stars=${encodeURIComponent(minStars)}`;

    const r = await fetch(url);
    const d = await r.json();
    LAST_REPORT_PAYLOAD = d;
    VISIBLE_CONST_SET = visibilitySetFromReportPayload(d);
    return VISIBLE_CONST_SET;
  }

  function renderReportFromCache(){
    const d = LAST_REPORT_PAYLOAD;
    if(!d || !report.open) return;

    const items = d.items || [];
    if(!items.length){
      report.body.innerHTML = `<div class="text-white-50">No constellations found for this report.</div>`;
      return;
    }
    report.body.innerHTML = items.map(reportRowHTML).join("");
  }

  async function loadReport(){
    const ll = readLatLonForUpdate();
    if(!ll) return;

    const season = (document.getElementById("season").value || "winter").trim();

    // Update subtitle
    report.sub.textContent = `${season.toUpperCase()} · lat ${ll.lat.toFixed(4)}, lon ${ll.lon.toFixed(4)}`;

    if(report.loading) return;
    report.loading = true;
    report.body.innerHTML = `<div class="text-white-50">Loading report…</div>`;

    try{
      await fetchSeasonVisibility(ll.lat, ll.lon, season);
      renderReportFromCache();

      const vis = LAST_REPORT_PAYLOAD?.counts?.visible ?? "";
      const tot = LAST_REPORT_PAYLOAD?.counts?.constellations_total ?? (LAST_REPORT_PAYLOAD?.items?.length || "");
      showToast("Report updated", `Visible: ${vis}/${tot} (season-only)`, 1600);
    } catch (err){
      console.error(err);
      report.body.innerHTML = `<div class="text-white-50">Failed to load report. Check /api/constellation_report.</div>`;
      showToast("Report failed", "Check /api/constellation_report", 2200, "error");
    } finally {
      report.loading = false;
    }
  }

  // =========================
  // Time controls + fetch (still used to render sky)
  // =========================
  function seasonDateUTC(season){
    const y = new Date().getFullYear();
    const map = { spring:[3,21], summer:[6,21], fall:[9,22], winter:[12,21] };
    const md = map[season] || map.winter;
    const hour = parseInt(document.getElementById("hour").value || "21", 10);
    return new Date(y, md[0]-1, md[1], hour, 0, 0).toISOString();
  }

  function setLoading(isLoading){
    const btnGo  = document.getElementById("btn-go");
    const btnLoc = document.getElementById("btn-loc");

    if(!btnGo.dataset.label)  btnGo.dataset.label  = btnGo.innerText;
    if(!btnLoc.dataset.label) btnLoc.dataset.label = btnLoc.innerText;

    btnGo.disabled  = isLoading;
    btnLoc.disabled = isLoading;

    btnGo.innerText  = isLoading ? "Loading…" : btnGo.dataset.label;
    btnLoc.innerText = isLoading ? "Loading…" : btnLoc.dataset.label;
  }

  // =========================
  // MAIN: updateSky
  // - fetch /api/sky
  // - fetch /api/constellation_report (season visibility)
  // - filter out hidden constellations BEFORE rendering (finder/search hides too)
  // =========================
  async function updateSky(lat, lon, ts){
    if(!Number.isFinite(lat) || !Number.isFinite(lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180){
      markInvalid(!(lat >= -90 && lat <= 90), !(lon >= -180 && lon <= 180), "Blocked request due to invalid coordinates.");
      return;
    }

    setLoading(true);
    showLoader("Fetching sky data…");

    const season = (document.getElementById("season").value || "winter").trim();

    const url =
      `/api/sky?lat=${encodeURIComponent(lat)}` +
      `&lon=${encodeURIComponent(lon)}` +
      `&ts=${encodeURIComponent(ts)}` +
      `&min_alt=${encodeURIComponent(MIN_ALT)}`;

    try{
      const r = await fetch(url);
      const d = await r.json();

      showLoader("Computing season visibility…");
      await fetchSeasonVisibility(lat, lon, season);

      const incoming = d.constellations || [];
      const visSet = VISIBLE_CONST_SET;

      // If report returns an empty set (all hidden), you'll see nothing (including finder list)
      CONSTS = (visSet && visSet.size)
        ? incoming.filter(c => visSet.has(c.name))
        : []; // season says none visible

      showLoader("Rendering sky…");
      renderConstellations();
      resetView();

      // If report is open, render cached payload (no extra fetch)
      if(report.open) renderReportFromCache();

      const cCount = CONSTS.length;
      const total = incoming.length;
      const aRows  = d.counts?.audio_csv_rows ?? "";
      showToast("Sky updated", `Shown: ${cCount}/${total}${aRows!=="" ? ` · Audio rows: ${aRows}` : ""}`, 1700);
    } catch(err){
      console.error(err);
      showToast("Failed to load sky", "Check /api/sky and /api/constellation_report", 2200, "error");
    } finally{
      hideLoader();
      setLoading(false);
    }
  }

  document.getElementById("btn-loc").onclick = async ()=>{
    if(!navigator.geolocation) return;

    setLoading(true);
    showLoader("Getting your location…");

    navigator.geolocation.getCurrentPosition(
      async (pos)=>{
        try{
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;

          document.getElementById("lat").value = lat.toFixed(6);
          document.getElementById("lon").value = lon.toFixed(6);
          clearCoordInvalid();

          await updateSky(lat, lon, seasonDateUTC(document.getElementById("season").value));
        } finally {
          // updateSky controls loader, but if it returns early for any reason:
          hideLoader();
          setLoading(false);
        }
      },
      (err)=>{
        hideLoader();
        setLoading(false);
        showToast("Location failed", err?.message || "Permission denied", 2200, "error");
      },
      { enableHighAccuracy:true, timeout:10000, maximumAge:60000 }
    );
  };

  document.getElementById("btn-go").onclick = ()=>{
    const ll = readLatLonForUpdate();
    if(!ll) return;
    updateSky(ll.lat, ll.lon, seasonDateUTC(document.getElementById("season").value));
  };

  // =========================
  // Main render
  // =========================
  function renderConstellations(){
    groupsLayer.innerHTML = "";
    CONST_INFO = {};

    for(const c of CONSTS){
      const name = c.name;
      const polylines = c.polylines || [];
      const lineStars = c.line_stars || [];
      let audioStars = c.audio_stars || [];

      if(!audioStars || audioStars.length === 0) continue;

      const allLinePts = [];
      const projLines = polylines.map(line=>{
        const pts = line.map(pt=>{
          const p = project(pt.alt, pt.az);
          allLinePts.push(p);
          return p;
        });
        return pts;
      });

      const projLineStars = lineStars.map(s => project(s.alt, s.az));
      const projAudioBase = audioStars.map(s => project(s.alt, s.az));

      const baseForCenter = allLinePts.length ? allLinePts : (projAudioBase.length ? projAudioBase : projLineStars);
      if(!baseForCenter.length) continue;

      const cen = centroid(baseForCenter);

      function spreadPoint(p){
        return {
          x: cen.x * CONST_SPREAD + (p.x - cen.x) * INTRA_SPREAD,
          y: cen.y * CONST_SPREAD + (p.y - cen.y) * INTRA_SPREAD
        };
      }

      const spreadLines = projLines.map(line => line.map(spreadPoint));
      const spreadLineStars = projLineStars.map(spreadPoint);

      let spreadAudio = audioStars.map(s=>{
        const p = spreadPoint(project(s.alt, s.az));
        return {...s, x:p.x, y:p.y};
      });

      if(SNAP_AUDIO_TO_LINES && spreadLines.length){
        const snapDist = SNAP_PX_AT_ZOOM1;
        const keepDist = KEEP_MAX_PX_AT_ZOOM1;

        spreadAudio = spreadAudio
          .map(s=>{
            const p = {x:s.x, y:s.y};
            const best = nearestPointOnPolylines(p, spreadLines);
            if(!best) return { ...s, _distToLine: Infinity };
            const d = Math.sqrt(best.d2);
            if(best.d2 <= snapDist*snapDist){
              return { ...s, x: best.x, y: best.y, snapped: true, snap_d: d, _distToLine: d };
            }
            return { ...s, _distToLine: d };
          })
          .filter(s => (s._distToLine ?? Infinity) <= keepDist);
      }

      if(!spreadAudio || spreadAudio.length === 0) continue;

      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      const allPtsForBounds = [
        ...spreadLines.flat(),
        ...spreadLineStars,
        ...spreadAudio.map(s => ({x:s.x, y:s.y}))
      ];
      allPtsForBounds.forEach(p=>{
        if(!p) return;
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
        maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
      });
      const center2 = { x:(minX+maxX)/2, y:(minY+maxY)/2 };

      CONST_INFO[name] = {
        minX, minY, maxX, maxY,
        centerX:center2.x, centerY:center2.y,
        audioCount: spreadAudio.length,
        lineCount: spreadLineStars.length
      };

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("class", "const-group");
      g.setAttribute("data-const", name);

      const hullPts = [];
      spreadLines.forEach(line=> line.forEach(p=> hullPts.push(p)));
      spreadLineStars.forEach(p=> hullPts.push(p));
      spreadAudio.forEach(s=> hullPts.push({x:s.x, y:s.y}));

      const hull = convexHull(hullPts);

      const hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
      hit.setAttribute("d", hullPath(hull, 22));
      hit.setAttribute("class", "const-hit");
      hit.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      hit.addEventListener("mouseleave", ()=> clearFocusSoon());
      hit.addEventListener("click", ()=> focusConstellation(name));
      g.appendChild(hit);

      for(const line of spreadLines){
        for(let i=0; i<line.length-1; i++){
          const a = line[i], b = line[i+1];
          const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
          ln.setAttribute("x1", a.x); ln.setAttribute("y1", a.y);
          ln.setAttribute("x2", b.x); ln.setAttribute("y2", b.y);
          ln.setAttribute("class", "const-line");
          g.appendChild(ln);
        }
      }

      const lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      lbl.setAttribute("text-anchor", "middle");
      lbl.setAttribute("class", "const-label");
      lbl.setAttribute("x", center2.x);
      lbl.setAttribute("y", center2.y);
      lbl.textContent = name;
      g.appendChild(lbl);

      for(const p of spreadLineStars){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", p.x);
        cc.setAttribute("cy", p.y);
        cc.setAttribute("r", lineStarR());
        cc.setAttribute("class", "star line");
        g.appendChild(cc);
      }

      for(const s of spreadAudio){
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", s.x);
        cc.setAttribute("cy", s.y);
        cc.setAttribute("r", magToR_audio(s.mag));
        cc.setAttribute("class", "star major");
        cc.dataset.starName = s.name || "";
        cc.dataset.const = name;

        cc.addEventListener("pointerdown", (e)=> e.stopPropagation());
        cc.addEventListener("mousedown", (e)=> e.stopPropagation());
        cc.addEventListener("click", (e)=>{
          e.stopPropagation();
          openStar({ ...s, const: name });
        });
        g.appendChild(cc);
      }

      groupsLayer.appendChild(g);
    }

    buildConstellationList();
    applyZoomVisibilityRules();

    WORLD_BOUNDS = computeWorldBounds();
    if(WORLD_BOUNDS){
      updateMinimapConstDots();
      if(MINIMAP_OPEN) updateMinimapRect();
    } else {
      mm.layer.innerHTML = "";
    }
  }

  // =========================
  // Init
  // =========================
  (function init(){
    showLoader("Initializing…");
    updateSky(37.5665, 126.9780, seasonDateUTC("winter"));
  })();
</script>
</body>
</html>
