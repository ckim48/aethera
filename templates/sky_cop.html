<!-- templates/sky.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Celestial Navigation - Hover Constellations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <style>
    :root{
      --panel: rgba(10,12,18,.82);
      --panel2: rgba(10,12,18,.92);
      --text: rgba(255,255,255,.90);
      --muted: rgba(255,255,255,.58);
      --glow: rgba(255,255,255,.55);
      --line: rgba(197,160,89,.65);
      --lineSoft: rgba(197,160,89,.18);
    }

    html,body{height:100%; margin:0; background:#000; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif;}
    #sky-container{
      position:fixed; inset:0;
      background-image:url('/static/images/dark_sky.jpg');
      background-size:cover; background-position:center;
      cursor:grab;
    }
    #sky-container.dragging{ cursor:grabbing; }
    svg{ width:100%; height:100%; display:block; }

    .star.major{
      fill:#fff;
      filter: drop-shadow(0 0 10px var(--glow));
      cursor:pointer;
      opacity: .95;
      transition: opacity .18s ease;
      pointer-events: auto;
    }

    .star.minor{
      fill: rgba(255,255,255,.85);
      filter: drop-shadow(0 0 6px rgba(255,255,255,.28));
      cursor: default;
      opacity: .60;
      pointer-events: none;
    }

    #view-port.has-focus .star{ opacity: .12; }
    #view-port.has-focus .const-group.is-focus .star{ opacity: 1; }

    .star{
      transform-box: fill-box;
      transform-origin: center;
      transition: transform 900ms ease, filter 900ms ease, opacity 260ms ease;
    }
    #view-port.has-focus .const-group.is-focus .star.major{
      transform: scale(1.45);
      filter: drop-shadow(0 0 18px rgba(255,255,255,.60));
    }

    #view-port.has-focus .const-group.is-focus .star{
      animation: starBlink var(--blink, 3.8s) ease-in-out infinite;
      animation-delay: var(--delay, 0s);
    }
    @keyframes starBlink{
      0%, 100% { opacity: 1; }
      45%      { opacity: var(--dim, .82); }
      60%      { opacity: 1; }
    }

    .const-lines{
      pointer-events:none;
      opacity: .55;
      transition: opacity .22s ease, filter .22s ease;
      filter: drop-shadow(0 0 10px rgba(197,160,89,.18));
    }
    .const-line{
      stroke: var(--lineSoft);
      stroke-width: 1.4;
      stroke-linecap: round;
      stroke-linejoin: round;
      vector-effect: non-scaling-stroke;
      transition: stroke .22s ease, opacity .22s ease;
      opacity: .65;
    }
    #view-port.has-focus .const-lines{ opacity: .10; }
    #view-port.has-focus .const-group.is-focus .const-lines{ opacity: 1; filter: drop-shadow(0 0 16px rgba(197,160,89,.35)); }
    #view-port.has-focus .const-group.is-focus .const-line{
      stroke: var(--line);
      opacity: 1;
    }

    .const-label{
      fill: var(--muted);
      font-weight: 900;
      letter-spacing: .20em;
      text-transform: uppercase;
      pointer-events:none;
      user-select:none;
      paint-order: stroke fill;
      stroke: rgba(0,0,0,.55);
      stroke-width: 3px;
      transition: opacity .18s ease;
    }
    #view-port.has-focus .const-label{ opacity: .10; }
    #view-port.has-focus .const-group.is-focus .const-label{ opacity: 1; fill: rgba(255,255,255,.78); }

    .const-hit{
      fill: rgba(255,255,255,.0001);
      stroke: rgba(255,255,255,0);
      pointer-events: all;
      cursor: pointer;
    }

    #finder{
      position:fixed; top:18px; left:18px;
      width:380px; max-width: calc(100vw - 36px);
      background: var(--panel);
      backdrop-filter: blur(18px);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 18px;
      z-index:2000;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    #finder .head{ padding:14px 14px 10px 14px; border-bottom:1px solid rgba(255,255,255,.10); }
    #finder .title{
      color:var(--text); font-weight:950; letter-spacing:.02em; font-size:1.02rem;
      margin:0 0 10px 0; display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    #finder .smallhint{ color:var(--muted); font-size:.82rem; margin:8px 0 0 0; }
    #finder .body{ padding: 12px; max-height: calc(100vh - 220px); overflow:auto; }
    #finder input{
      background: rgba(255,255,255,.06) !important;
      border: 1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
    }
    #finder input::placeholder{ color: rgba(255,255,255,.55); }

    .const-item{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; padding:10px 10px; border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      margin:8px 0; cursor:pointer;
      transition: transform .08s ease, background .12s ease, border-color .12s ease;
    }
    .const-item:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.16);
    }
    .const-item.active{
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.22);
    }
    .const-name{ color:var(--text); font-weight:900; letter-spacing:.02em; }
    .const-count{ color:var(--muted); font-size:.85rem; }

    #sidebar{
      position:fixed; right:-520px; top:0; bottom:0;
      width:480px; max-width: calc(100vw - 36px);
      background: var(--panel2);
      backdrop-filter: blur(22px);
      border-left:1px solid rgba(255,255,255,.12);
      z-index:2200;
      transition: .55s cubic-bezier(.16,1,.3,1);
      padding:24px 22px;
      color:#fff;
      overflow:auto;
    }
    #sidebar.open{ right:0; }
    #closeSide{
      cursor:pointer; opacity:.65; font-size:1.8rem; line-height:1;
      width:44px; height:44px; border-radius:12px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
    }
    #s-name{ font-weight: 950; margin:14px 0 6px 0; }
    #s-const{ color:#7fd3ff; letter-spacing:.22em; text-transform:uppercase; font-size:.82rem; margin:0 0 14px 0; }
    #s-meta .rowish{
      display:flex; justify-content:space-between; gap:14px;
      padding:10px 0; border-bottom: 1px solid rgba(255,255,255,.08);
      font-size:.92rem;
    }
    #s-meta .rowish b{ font-weight:950; }
    #s-audio{ width:100%; filter: invert(1); margin-top:12px; }

    #player .btn{ border-radius: 999px; }
    #player .form-range{ margin:0; }
    #p-now{ white-space: nowrap; overflow:hidden; text-overflow: ellipsis; max-width: 100%; }

    #ui-overlay{
      position:fixed; bottom:18px; left:50%; transform:translateX(-50%);
      z-index:2100;
      width:min(980px, calc(100vw - 36px));
      background: var(--panel);
      backdrop-filter: blur(18px);
      border:1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 10px 12px;
      display:flex; gap:10px; align-items:center;
      flex-wrap: wrap;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    #ui-overlay .ctl{
      background: rgba(255,255,255,.06) !important;
      border:1px solid rgba(255,255,255,.12) !important;
      color:#fff !important;
      border-radius: 999px !important;
      padding: 10px 14px;
    }
    #ui-overlay .btn{
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 900;
      letter-spacing:.02em;
      white-space:nowrap;
    }

    #status{
      position:fixed; top:18px; right:18px;
      z-index:2050;
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;
      border-radius: 14px;
      color: rgba(255,255,255,.78);
      font-size:.86rem;
      backdrop-filter: blur(10px);
      max-width: min(520px, calc(100vw - 36px));
      line-height: 1.35;
      white-space: pre-line;
    }
  </style>
</head>

<body>
  <div id="sky-container">
    <svg id="sky-svg">
      <g id="view-port">
        <g id="groups-layer"></g>
      </g>
    </svg>
  </div>

  <div id="finder">
    <div class="head">
      <div class="title">
        <span>Constellation Finder</span>
        <button id="btn-reset" class="btn btn-sm btn-outline-light" style="border-radius:999px;">Reset</button>
      </div>
      <input id="const-q" class="form-control" placeholder="Search constellation (e.g., Orion)" />
      <p class="smallhint">Hover constellation to highlight. Major stars are clickable.</p>
    </div>
    <div class="body" id="const-list"></div>
  </div>

  <div id="sidebar">
    <div class="d-flex justify-content-end">
      <div id="closeSide" title="Close">&times;</div>
    </div>
    <h1 id="s-name">Star</h1>
    <p id="s-const">CONSTELLATION</p>

    <audio id="s-audio" controls></audio>

    <div id="player" class="mt-3">
      <div class="d-flex align-items-center gap-2">
        <button id="p-prev" class="btn btn-outline-light btn-sm">Prev</button>
        <button id="p-play" class="btn btn-light btn-sm" style="font-weight:900;">Play</button>
        <button id="p-next" class="btn btn-outline-light btn-sm">Next</button>
        <div class="ms-auto text-white-50" id="p-time" style="font-size:.85rem;">0:00 / 0:00</div>
      </div>

      <input id="p-seek" type="range" class="form-range mt-2" min="0" max="1000" value="0" />
      <div class="text-white-50" id="p-now" style="font-size:.85rem; margin-top:6px;">No audio selected</div>
    </div>

    <div id="s-meta" class="mt-3"></div>
  </div>

  <div id="status">Loading…</div>

  <div id="ui-overlay">
    <button id="btn-loc" class="btn btn-outline-light">Use my location</button>
    <input id="lat" class="ctl form-control" style="max-width: 170px" placeholder="Lat" value="37.5665" />
    <input id="lon" class="ctl form-control" style="max-width: 170px" placeholder="Lon" value="126.9780" />

    <select id="season" class="ctl form-select" style="max-width: 180px">
      <option value="spring">Spring (Mar 21)</option>
      <option value="summer">Summer (Jun 21)</option>
      <option value="fall">Fall (Sep 22)</option>
      <option value="winter" selected>Winter (Dec 21)</option>
    </select>

    <input id="hour" type="number" min="0" max="23" class="ctl form-control" style="max-width: 120px" value="21" title="Local hour" />
    <button id="btn-go" class="btn btn-light">Show sky</button>
  </div>

<script>
  // =========================
  // TUNE
  // =========================
  const SKY_SCALE = 34;
  const CONST_SPREAD = 2.6;
  const INTRA_SPREAD = 1.0;

  const ZOOM_MIN = 0.35, ZOOM_MAX = 9.0;

  const STAR_MAJOR_MIN = 3.2, STAR_MAJOR_MAX = 12.0;
  const STAR_MINOR_MIN = 1.2, STAR_MINOR_MAX = 4.4;

  const LABEL_SHOW_ZOOM = 0.85;
  const HIT_PAD_PX = 22;

  const BLINK_MIN = 2.9;
  const BLINK_MAX = 5.9;
  const DIM_MIN   = 0.72;
  const DIM_MAX   = 0.88;

  const LINE_SAFETY_MAX_LEN = 900;

  const MIN_ALT = -8;

  // =========================
  // STATE
  // =========================
  let STARS = [];
  let CONST_INFO = {};
  let FOCUSED_CONST = null;

  let CONST_LINES_IDS = {};
  let CONST_LINES_NAMES = {};

  const svg = document.getElementById("sky-svg");
  const viewport = document.getElementById("view-port");
  const statusEl = document.getElementById("status");
  const groupsLayer = document.getElementById("groups-layer");
  const sky = document.getElementById("sky-container");

  function normNameReminder(s){
    return (s || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
  }

  // =========================
  // MST (only for constellations without templates)
  // =========================
  function buildMST(points) {
    const n = points.length;
    if (n < 2) return [];
    const used = new Array(n).fill(false);
    const dists = new Array(n).fill(Infinity);
    const parent = new Array(n).fill(-1);
    const edges = [];

    dists[0] = 0;
    for (let i = 0; i < n; i++) {
      let u = -1;
      for (let v = 0; v < n; v++) {
        if (!used[v] && (u === -1 || dists[v] < dists[u])) u = v;
      }
      if (u === -1 || dists[u] === Infinity) break;
      used[u] = true;
      if (parent[u] !== -1) edges.push([parent[u], u]);
      for (let v = 0; v < n; v++) {
        if (!used[v]) {
          const d2 = Math.pow(points[u].x - points[v].x, 2) + Math.pow(points[u].y - points[v].y, 2);
          if (d2 < dists[v]) { dists[v] = d2; parent[v] = u; }
        }
      }
    }
    return edges;
  }

  // =========================
  // PAN & ZOOM
  // =========================
  let isDragging=false, lastX=0, lastY=0;
  let tx=0, ty=0, zoom=1.0;

  function setTransform(){
    viewport.setAttribute("transform", `translate(${tx}, ${ty}) scale(${zoom})`);
    updateDynamicLabelSizing();
    applyZoomVisibilityRules();
  }

  function zoomAbout(screenX, screenY, factor){
    const pt = svg.createSVGPoint();
    pt.x = screenX; pt.y = screenY;
    const ctm = viewport.getCTM();
    if(!ctm) return;
    const inv = ctm.inverse();
    const world = pt.matrixTransform(inv);
    const newZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoom * factor));
    if(newZoom === zoom) return;
    zoom = newZoom;
    tx = screenX - world.x * zoom;
    ty = screenY - world.y * zoom;
    setTransform();
  }

  sky.addEventListener("mousedown", (e)=>{
    isDragging = true;
    sky.classList.add("dragging");
    lastX = e.clientX; lastY = e.clientY;
  });
  window.addEventListener("mousemove", (e)=>{
    if(!isDragging) return;
    tx += (e.clientX - lastX);
    ty += (e.clientY - lastY);
    lastX = e.clientX; lastY = e.clientY;
    setTransform();
  });
  window.addEventListener("mouseup", ()=>{
    isDragging = false;
    sky.classList.remove("dragging");
  });
  sky.addEventListener("wheel", (e)=>{
    e.preventDefault();
    zoomAbout(e.clientX, e.clientY, e.deltaY < 0 ? 1.12 : 0.89);
  }, { passive:false });

  function setupViewBox(){
    const w = window.innerWidth, h = window.innerHeight;
    svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
    if(tx === 0 && ty === 0){
      tx = w/2; ty = h/2; zoom = 1.0;
      setTransform();
    }
  }
  window.addEventListener("resize", setupViewBox);
  setupViewBox();

  // =========================
  // Projection + star size
  // =========================
  function project(altDeg, azDeg){
    const r = (90 - altDeg) * SKY_SCALE;
    const a = azDeg * Math.PI / 180;
    return { x: r * Math.sin(a), y: -r * Math.cos(a) };
  }

  function magToR_major(mag){
    const t = Math.max(-1, Math.min(6, mag));
    const r = STAR_MAJOR_MAX - (t * 1.05);
    return Math.max(STAR_MAJOR_MIN, Math.min(STAR_MAJOR_MAX, r));
  }
  function magToR_minor(mag){
    const t = Math.max(-1, Math.min(6, mag));
    const r = STAR_MINOR_MAX - (t * 0.42);
    return Math.max(STAR_MINOR_MIN, Math.min(STAR_MINOR_MAX, r));
  }

  function centroid(pts){
    const n = pts.length || 1;
    let sx=0, sy=0;
    pts.forEach(p=>{ sx += p.x; sy += p.y; });
    return { x: sx/n, y: sy/n };
  }

  // =========================
  // Convex hull (hit area)
  // =========================
  function cross(o, a, b){
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
  }
  function convexHull(points){
    const uniq = [];
    const seen = new Set();
    for(const p of points){
      const k = `${Math.round(p.x*10)}|${Math.round(p.y*10)}`;
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(p);
    }
    if(uniq.length <= 2) return uniq;
    uniq.sort((p,q)=> p.x === q.x ? p.y - q.y : p.x - q.x);
    const lower = [];
    for(const p of uniq){
      while(lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
      lower.push(p);
    }
    const upper = [];
    for(let i=uniq.length-1; i>=0; i--){
      const p = uniq[i];
      while(upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
      upper.push(p);
    }
    upper.pop(); lower.pop();
    return lower.concat(upper);
  }

  function hullPath(points, pad){
    if(points.length === 0) return "";
    if(points.length === 1){
      const p = points[0];
      const r = pad;
      return `M ${p.x-r} ${p.y} a ${r} ${r} 0 1 0 ${2*r} 0 a ${r} ${r} 0 1 0 ${-2*r} 0`;
    }
    if(points.length === 2){
      const a = points[0], b = points[1];
      const dx = b.x-a.x, dy = b.y-a.y;
      const len = Math.hypot(dx,dy) || 1;
      const nx = -dy/len, ny = dx/len;
      return `M ${a.x + nx*pad} ${a.y + ny*pad} L ${b.x + nx*pad} ${b.y + ny*pad} L ${b.x - nx*pad} ${b.y - ny*pad} L ${a.x - nx*pad} ${a.y - ny*pad} Z`;
    }
    const c = centroid(points);
    const expanded = points.map(p=>{
      const dx = p.x - c.x, dy = p.y - c.y;
      const len = Math.hypot(dx,dy) || 1;
      return { x: p.x + (dx/len)*pad, y: p.y + (dy/len)*pad };
    });
    let d = `M ${expanded[0].x} ${expanded[0].y}`;
    for(let i=1; i<expanded.length; i++) d += ` L ${expanded[i].x} ${expanded[i].y}`;
    d += " Z";
    return d;
  }

  // =========================
  // Focus
  // =========================
  function setFocusConstellation(name){
    if(FOCUSED_CONST === name) return;
    FOCUSED_CONST = name;
    if(name) viewport.classList.add("has-focus");
    else viewport.classList.remove("has-focus");

    document.querySelectorAll(".const-group").forEach(g=>{
      g.classList.toggle("is-focus", name && g.getAttribute("data-const") === name);
    });
    document.querySelectorAll(".const-item").forEach(el=>{
      el.classList.toggle("active", name && el.getAttribute("data-name") === name);
    });
  }

  let blurTimer = null;
  function clearFocusSoon(){
    if(blurTimer) clearTimeout(blurTimer);
    blurTimer = setTimeout(()=> setFocusConstellation(null), 120);
  }

  // =========================
  // Labels
  // =========================
  function updateDynamicLabelSizing(){
    const labels = document.querySelectorAll(".const-label");
    const px = Math.max(11, Math.min(22, 14 / Math.max(0.6, zoom)));
    labels.forEach(l => l.style.fontSize = px + "px");
  }
  function applyZoomVisibilityRules(){
    document.querySelectorAll(".const-label").forEach(l=>{
      l.style.display = (zoom <= LABEL_SHOW_ZOOM) ? "" : "none";
    });
  }

  // =========================
  // Sidebar + Player (unchanged)
  // =========================
  const aud = document.getElementById("s-audio");
  const pPlay = document.getElementById("p-play");
  const pPrev = document.getElementById("p-prev");
  const pNext = document.getElementById("p-next");
  const pSeek = document.getElementById("p-seek");
  const pTime = document.getElementById("p-time");
  const pNow  = document.getElementById("p-now");

  let PLAYLIST = [];
  let PLAY_INDEX = -1;

  function fmtTime(sec){
    if(!isFinite(sec)) return "0:00";
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec / 60);
    const s = String(sec % 60).padStart(2, "0");
    return `${m}:${s}`;
  }
  function updatePlayButton(){ pPlay.textContent = aud.paused ? "Play" : "Pause"; }

  function setPlaylistForConstellation(constName){
    PLAYLIST = (STARS || [])
      .filter(s => s.const === constName && s.is_main && s.audio)
      .sort((a,b) => (a.mag ?? 99) - (b.mag ?? 99));
  }

  function openStarCore(m, autoPlay){
    document.getElementById("s-name").innerText = m.name;
    document.getElementById("s-const").innerText = m.const;

    const meta = Object.entries(m.meta || {})
      .filter(([k,v]) => v && !["id","ra","dec","is_main","Star Name","Constellation","File"].includes(k))
      .slice(0, 28)
      .map(([k,v]) => `<div class="rowish"><span>${k}</span><b>${v}</b></div>`)
      .join("");

    document.getElementById("s-meta").innerHTML = meta || `<div class="text-white-50">No metadata.</div>`;

    if(m.audio){
      aud.src = m.audio;
      aud.style.display = "";
      pNow.textContent = `Now: ${m.name} · ${m.const}`;
      if(autoPlay) aud.play().catch(()=>{});
    } else {
      aud.pause(); aud.removeAttribute("src"); aud.style.display = "none";
      pNow.textContent = "No audio available";
    }

    document.getElementById("sidebar").classList.add("open");
    updatePlayButton();
  }

  function playAt(index){
    if(!PLAYLIST.length) return;
    PLAY_INDEX = Math.max(0, Math.min(PLAYLIST.length - 1, index));
    const m = PLAYLIST[PLAY_INDEX];
    openStarCore(m, true);
  }

  function openStar(m){
    setPlaylistForConstellation(m.const);
    const idx = PLAYLIST.findIndex(x => x.id === m.id);
    PLAY_INDEX = idx >= 0 ? idx : 0;
    openStarCore(m, true);
  }

  pPlay.addEventListener("click", ()=>{
    if(!aud.src){ if(PLAYLIST.length) playAt(PLAY_INDEX >= 0 ? PLAY_INDEX : 0); return; }
    if(aud.paused) aud.play().catch(()=>{}); else aud.pause();
  });
  pPrev.addEventListener("click", ()=>{ if(!PLAYLIST.length) return; playAt((PLAY_INDEX - 1 + PLAYLIST.length) % PLAYLIST.length); });
  pNext.addEventListener("click", ()=>{ if(!PLAYLIST.length) return; playAt((PLAY_INDEX + 1) % PLAYLIST.length); });

  aud.addEventListener("timeupdate", ()=>{
    if(!isFinite(aud.duration) || aud.duration <= 0) return;
    pSeek.value = Math.floor((aud.currentTime / aud.duration) * 1000);
    pTime.textContent = `${fmtTime(aud.currentTime)} / ${fmtTime(aud.duration)}`;
    updatePlayButton();
  });
  aud.addEventListener("loadedmetadata", ()=>{ pTime.textContent = `${fmtTime(0)} / ${fmtTime(aud.duration)}`; pSeek.value = 0; updatePlayButton(); });
  aud.addEventListener("play", updatePlayButton);
  aud.addEventListener("pause", updatePlayButton);

  pSeek.addEventListener("input", ()=>{
    if(!isFinite(aud.duration) || aud.duration <= 0) return;
    aud.currentTime = (parseInt(pSeek.value, 10) / 1000) * aud.duration;
  });

  aud.addEventListener("ended", ()=>{ if(PLAYLIST.length) pNext.click(); });
  document.getElementById("closeSide").onclick = ()=>{ document.getElementById("sidebar").classList.remove("open"); };

  // =========================
  // Finder list
  // =========================
  function buildConstellationList(){
    const list = document.getElementById("const-list");
    const q = (document.getElementById("const-q").value || "").trim().toLowerCase();
    const names = Object.keys(CONST_INFO).sort().filter(n => !q || n.toLowerCase().includes(q));
    list.innerHTML = names.map(n=>{
      const info = CONST_INFO[n];
      return `<div class="const-item" data-name="${n}">
        <div>
          <div class="const-name">${n}</div>
          <div class="const-count">${info.count} stars</div>
        </div>
        <div class="text-white-50" style="font-weight:950;">›</div>
      </div>`;
    }).join("");

    list.querySelectorAll(".const-item").forEach(el=>{
      const name = el.getAttribute("data-name");
      el.addEventListener("mouseenter", ()=> setFocusConstellation(name));
      el.addEventListener("mouseleave", ()=> clearFocusSoon());
      el.addEventListener("click", ()=> focusConstellation(name));
    });
  }
  document.getElementById("const-q").addEventListener("input", buildConstellationList);

  function focusConstellation(name){
    setFocusConstellation(name);
    const info = CONST_INFO[name];
    if(!info) return;
    const w = window.innerWidth, h = window.innerHeight;
    const pad = 140;
    const bw = Math.max(80, info.maxX - info.minX), bh = Math.max(80, info.maxY - info.minY);
    zoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, Math.min((w-2*pad)/bw, (h-2*pad)/bh)));
    tx = (w/2) - info.centerX * zoom;
    ty = (h/2) - info.centerY * zoom;
    setTransform();
  }

  function resetView(){
    setFocusConstellation(null);
    tx = window.innerWidth/2; ty = window.innerHeight/2; zoom = 1.0;
    setTransform();
  }
  document.getElementById("btn-reset").onclick = resetView;

  function applyStarTwinkleVars(scopeEl){
    const stars = (scopeEl || document).querySelectorAll(".star");
    stars.forEach((el, idx)=>{
      const t = BLINK_MIN + ((idx * 0.618033) % 1) * (BLINK_MAX - BLINK_MIN);
      const dim = DIM_MIN + ((idx * 0.414213) % 1) * (DIM_MAX - DIM_MIN);
      el.style.setProperty("--blink", t.toFixed(2) + "s");
      el.style.setProperty("--dim", dim.toFixed(2));
      el.style.setProperty("--delay", (-((idx * 0.73) % t)).toFixed(2) + "s");
    });
  }

  // =========================
  // Edge building
  // =========================
  function edgesFromIdLines(proj, lines){
    if(!lines || !lines.length) return [];
    const idMap = new Map(proj.map((p, i) => [p.id, i]));
    const edges = [];
    lines.forEach(([a,b])=>{
      if(idMap.has(a) && idMap.has(b) && a !== b) edges.push([idMap.get(a), idMap.get(b)]);
    });
    return edges;
  }

  function edgesFromNameLines(proj, lines){
    if(!lines || !lines.length) return [];
    const nameMap = new Map(proj.map((p, i) => [normNameReminder(p.name), i]));
    const edges = [];
    lines.forEach(([a,b])=>{
      const ia = nameMap.get(normNameReminder(a));
      const ib = nameMap.get(normNameReminder(b));
      if(ia !== undefined && ib !== undefined && ia !== ib) edges.push([ia, ib]);
    });
    return edges;
  }

  // =========================
  // RENDER
  // =========================
  function render(){
    groupsLayer.innerHTML = "";
    CONST_INFO = {};

    const groups = {};
    STARS.forEach(s=>{ (groups[s.const] ||= []).push(s); });

    Object.keys(groups).sort().forEach((constName)=>{
      const members = groups[constName];
      if(!members.length) return;

      const projMaj = members.map(m=>{
        const p = project(m.alt, m.az);
        return {...m, x:p.x, y:p.y};
      });

      const c = centroid(projMaj);
      const projMaj2 = projMaj.map(p => ({
        ...p,
        x: c.x * CONST_SPREAD + (p.x - c.x) * INTRA_SPREAD,
        y: c.y * CONST_SPREAD + (p.y - c.y) * INTRA_SPREAD
      }));
      const c2 = centroid(projMaj2);

      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      projMaj2.forEach(p=>{ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); });
      CONST_INFO[constName] = { count:projMaj2.length, minX, minY, maxX, maxY, centerX:c2.x, centerY:c2.y };

      const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g.setAttribute("class", "const-group");
      g.setAttribute("data-const", constName);

      const gg = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gg.setAttribute("class", "const-inner");
      gg.setAttribute("transform", `translate(${c2.x}, ${c2.y})`);

      const hull = convexHull(projMaj2);
      const hit = document.createElementNS("http://www.w3.org/2000/svg", "path");
      hit.setAttribute("d", hullPath(hull, HIT_PAD_PX));
      hit.setAttribute("class", "const-hit");
      hit.setAttribute("transform", `translate(${-c2.x}, ${-c2.y})`);
      hit.addEventListener("mouseenter", ()=> setFocusConstellation(constName));
      hit.addEventListener("mouseleave", ()=> clearFocusSoon());
      hit.addEventListener("click", ()=> focusConstellation(constName));
      gg.appendChild(hit);

      // lines
      const linesG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      linesG.setAttribute("class", "const-lines");
      linesG.setAttribute("transform", `translate(${-c2.x}, ${-c2.y})`);

      const idLines = CONST_LINES_IDS[constName];
      const nameLines = CONST_LINES_NAMES[constName];

      // IMPORTANT CHANGE:
      // ID → Name → MST fallback ONLY IF there is NO template for this constellation.
      const hasTemplate = (idLines && idLines.length) || (nameLines && nameLines.length);

      let edges = edgesFromIdLines(projMaj2, idLines);
      if(!edges.length) edges = edgesFromNameLines(projMaj2, nameLines);
      if(!edges.length && !hasTemplate) edges = buildMST(projMaj2);

      edges.forEach(([i, j]) => {
        const a = projMaj2[i], b = projMaj2[j];
        if (Math.hypot(a.x - b.x, a.y - b.y) > LINE_SAFETY_MAX_LEN) return;
        const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
        ln.setAttribute("x1", a.x); ln.setAttribute("y1", a.y);
        ln.setAttribute("x2", b.x); ln.setAttribute("y2", b.y);
        ln.setAttribute("class", "const-line");
        linesG.appendChild(ln);
      });
      gg.appendChild(linesG);

      const lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      lbl.setAttribute("text-anchor", "middle");
      lbl.setAttribute("class", "const-label");
      lbl.textContent = constName;
      gg.appendChild(lbl);

      const starsG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      starsG.setAttribute("transform", `translate(${-c2.x}, ${-c2.y})`);

      projMaj2.forEach(m=>{
        const cc = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        cc.setAttribute("cx", m.x);
        cc.setAttribute("cy", m.y);

        const isMain = !!m.is_main;
        const r = isMain ? magToR_major(m.mag) : magToR_minor(m.mag);
        cc.setAttribute("r", r);

        cc.setAttribute("class", isMain ? "star major" : "star minor");

        if(isMain && m.audio){
          cc.addEventListener("click", (e)=>{ e.stopPropagation(); openStar(m); });
        }
        starsG.appendChild(cc);
      });

      gg.appendChild(starsG);

      g.appendChild(gg);
      groupsLayer.appendChild(g);
      applyStarTwinkleVars(g);
    });

    buildConstellationList();
    updateDynamicLabelSizing();
    applyZoomVisibilityRules();
  }

  function seasonDateUTC(season){
    const y = new Date().getFullYear();
    const map = { spring:[3,21], summer:[6,21], fall:[9,22], winter:[12,21] };
    const md = map[season] || map.winter;
    const hour = parseInt(document.getElementById("hour").value || "21", 10);
    return new Date(y, md[0]-1, md[1], hour, 0, 0).toISOString();
  }

  async function updateSky(lat, lon, ts){
    statusEl.textContent = "Loading sky…";
    const url =
      `/api/sky?lat=${encodeURIComponent(lat)}` +
      `&lon=${encodeURIComponent(lon)}` +
      `&ts=${encodeURIComponent(ts)}` +
      `&scale=55` +
      `&min_alt=${encodeURIComponent(MIN_ALT)}`;
    const r = await fetch(url);
    const d = await r.json();

    STARS = d.stars || [];
    CONST_LINES_IDS = d.const_lines_ids || {};
    CONST_LINES_NAMES = d.const_lines_names || {};

    statusEl.textContent =
      `Stars (all): ${STARS.length}\n` +
      `Visible audio stars: ${d.counts?.visible_major ?? "?"}\n` +
      `Hover constellation to highlight`;

    render();
    resetView();
  }

  document.getElementById("btn-loc").onclick = ()=>{
    if(navigator.geolocation) navigator.geolocation.getCurrentPosition((pos)=>{
      document.getElementById("lat").value = pos.coords.latitude.toFixed(6);
      document.getElementById("lon").value = pos.coords.longitude.toFixed(6);
    });
  };

  document.getElementById("btn-go").onclick = ()=>{
    updateSky(
      document.getElementById("lat").value,
      document.getElementById("lon").value,
      seasonDateUTC(document.getElementById("season").value)
    );
  };

  (function init(){
    updateSky(37.5665, 126.9780, seasonDateUTC("winter"));
  })();
</script>
</body>
</html>
